<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Staring Array Module (rystare) &mdash; pyradi  documentation</title>
    
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="pyradi  documentation" href="index.html" />
    <link rel="next" title="Probability tools (ryprob)" href="ryprob.html" />
    <link rel="prev" title="Bulk detector modelling" href="rydetector.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="ryprob.html" title="Probability tools (ryprob)"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="rydetector.html" title="Bulk detector modelling"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">pyradi  documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="staring-array-module-rystare">
<h1>Staring Array Module (rystare)<a class="headerlink" href="#staring-array-module-rystare" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>This module provides a high level model for CCD and CMOS staring array
signal chain modelling.  The model accepts an input image in photon rate irradiance units
and then proceeds to calculate the various noise components and
signal components along the signal flow chain.</p>
<p>The code in this module serves as an example of implementation of a high-level
CCD/CMOS photosensor signal chain model. The model is described in the article
&#8216;High-level numerical simulations of noise in solid-state photosensors:
review and tutorial&#8217; by Mikhail Konnik and James Welsh, arXiv:1412.4031v1 [astro-ph.IM].
The code was originally written in Matlab and used for the Adaptive Optics
simulations and study of noise propagation in wavefront sensors, but can be
used for many other applications involving CCD/CMOS
photosensors.  The original files are available at:</p>
<ul class="simple">
<li>Paper: <a class="reference external" href="http://arxiv.org/pdf/1412.4031.pdf">http://arxiv.org/pdf/1412.4031.pdf</a></li>
<li>Matlab code: <a class="reference external" href="https://bitbucket.org/aorta/highlevelsensorsim">https://bitbucket.org/aorta/highlevelsensorsim</a></li>
</ul>
<p>The original Matlab code was ported to Python and extended
in a number of ways.  The core of the model remains the original Konnik model
as implemented in the Matlab code.  The  Python code was validated
against results obtained with the Matlab code, up to a point
and then substantially reworked and refactored.  During the refactoring
due diligence was applied with regression testing, checking the new
results against the previous results.  The results were communicated and
confirmed with Konnik.  A number of corrections were also made to Konnik&#8217;s
original code, some with his cooperation and some without his involvement.</p>
<p>The documentation in the code was copied from Konnik&#8217;s Matlab code, so
he deserves the credit for the very detailed documentation.  His documentation
was extracted from the paper quoted above.</p>
<p>The sample Python code (derived from Konnik&#8217;s code) in the repository models two different cases</p>
<ul class="simple">
<li>a simple model: which is completely linear (no non-linearities),
where all noise are Gaussian, and without source follower noise,</li>
<li>an advanced model: which has V/V and V/e non-linearities,
Wald or lognormal noise, source follower and sense node noise
sources and even ADC non-linearities.</li>
</ul>
<p>The Python code supports enabling/disabling of key components by using flags.</p>
<p>In the documentation for the Matlab code Konnik expressed the hope &#8220;that this
model will be useful for somebody, or at least save someone&#8217;s time.
The model can be (and should be) criticized.&#8221;  Indeed it has, thanks Mikhail!
Konnik quotes George E. P. Box, the famous statistician, and who said that
&#8220;essentially, all models are wrong, but some are useful&#8221;.</p>
</div>
<div class="section" id="signal-flow">
<h2>Signal Flow<a class="headerlink" href="#signal-flow" title="Permalink to this headline">¶</a></h2>
<p>The process from incident photons to the digital numbers appearing in the
image is outlined in the picture below.
The input image must be provided in photon rate irradiance units [q/(s.m<sup>2</sup>)],
with photon noise already present in the image.  The count of photons
captured in the detector is determined from the irradiance by accounting
for the detector area and integration time.
Then, the code models the process of conversion from photons to
electrons and subsequently to signal voltage. Various noise sources
are modelled to derive at a realistic image model.
Finally, the ADC converts the voltage signal into digital numbers.
The whole process is depicted in the figure below.</p>
<a class="reference internal image-reference" href="_images/camerascheme-horiz.png"><img alt="camerascheme-horiz.png" class="align-center" src="_images/camerascheme-horiz.png" style="width: 812.0px; height: 244.0px;" /></a>
<p>Many noise sources contribute to the resulting noise image that is produced by
the sensor. Noise sources can be broadly classified as either
<em>fixed-pattern (time-invariant)</em> or <em>temporal (time-variant)</em>
noise. Fixed-pattern noise refers to any spatial pattern that does not change
significantly from frame to frame. Temporal noise, on the other hand, changes
from one frame to the next.  All these noise sources are modelled in the code.
For more details see Konnik&#8217;s original paper or the docstrings present in the code.</p>
</div>
<div class="section" id="changes-to-matlab-code">
<h2>Changes to Matlab code<a class="headerlink" href="#changes-to-matlab-code" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li>Renamed many, if not all, variables to be more descriptive.</li>
<li>Created a number of new functions by splitting up the Matlab functions for increased modularity.</li>
<li>Store (almost) all input and output variables in an HDF5 file for full record keeping.</li>
<li>Precalculate the image data input as HDF5 files with linear detector parameters embedded
in the file.  This was done to support future image size calculations.  The idea is to
embed the target frequency in the data file to relate observed performance with the
frequency on the focal plane.</li>
<li>Moved sourcefollower calcs out from under dark signal flag. sourcefollower noise is
now always calculated irrespective of whether dark noise is selected or not.</li>
<li>Input image now photon rate irradiance q/(m2.s), image should already include photon noise
in input.  Removed from ccd library: irradiance from radiant to photon units, adding
photon shot noise.  This functionality has been added to the image generation code.</li>
<li>Both CCD and CMOS now have fill factors, the user can set CCD fill factor differently
from CMOS fill factor.  The fill factor value is used as-in in the rest of the code,
without checking for CCD or CMOS.  This is done because CCD fill factor is 1.0 for
full frame sensors but can be less than 1.0 for other types of CCD.</li>
<li>Now uses SciPy&#8217;s CODATA constants where these are available.</li>
<li>Put all of the code into a single file rystare.py in the pyradi repository.</li>
<li>Minor changes to Konnik&#8217;s excellent documentation to be Sphinx compatible.
Documentation is now generated as part of the pyradi documentation.</li>
</ol>
</div>
<div class="section" id="example-code">
<h2>Example Code<a class="headerlink" href="#example-code" title="Permalink to this headline">¶</a></h2>
<p>The two examples provided by Konnik are merged into a single code, with flags to
select between the two options.  The code is found at the end of the module file
in the <cite>__main__</cite> part of the module file.  Set <cite>doTest = &#8216;Simple&#8217;</cite> or <cite>doTest = &#8216;Advanced&#8217;</cite>
depending on which model.
Either example will run the <cite>photosensor</cite> function
(all functions are thoroughly documented in the Python code, thanks Mikhail!).</p>
<p>The two prepared image files are both 256x256 in size.  New images can be generated
following the example shown  in the <cite>__main__</cite> part of the rystare.py module file
(use the function <cite>create_HDF5_image</cite> as a starting point to develop your own).</p>
<p>The easiest way to run the code is to open a command window in the installation directory
and run the <cite>run_example</cite> function in the module code.  This will load the module and
execute the example code function. Running the example code function will create files
with names similar to <cite>PSOutput.hdf5</cite> and <cite>PSOutput.txt</cite>.  To run the example, create
a python file with the following contents and run it at the command line prompt:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pyradi.rystare</span> <span class="kn">as</span> <span class="nn">rystare</span>
<span class="n">rystare</span><span class="o">.</span><span class="n">run_example</span><span class="p">(</span><span class="s1">&#39;Advanced&#39;</span><span class="p">,</span><span class="s1">&#39;Output&#39;</span><span class="p">,</span> <span class="n">doPlots</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">doHisto</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">doImages</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">rystare</span><span class="o">.</span><span class="n">run_example</span><span class="p">(</span><span class="s1">&#39;Simple&#39;</span><span class="p">,</span><span class="s1">&#39;Output&#39;</span><span class="p">,</span> <span class="n">doPlots</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">doHisto</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">doImages</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>By setting all the flags to True the example code will print a number of images to file.
Plotting the results to file takes a while.  Execution is much faster with all flags set to False.</p>
<p>Study the text file using a normal text editor and study the HDF5 file by using the viewer
available from <a class="reference external" href="https://www.hdfgroup.org/products/java/hdfview/">https://www.hdfgroup.org/products/java/hdfview/</a>.</p>
<p>Some time in future an IPython notebook will be released on
<a class="reference external" href="https://github.com/NelisW/ComputationalRadiometry">https://github.com/NelisW/ComputationalRadiometry</a>.</p>
<p>The full code for the example file is as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1">#prepare so long for Python 3</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">unicode_literals</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">os.path</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">cm</span> <span class="k">as</span> <span class="n">mcm</span>
<span class="kn">import</span> <span class="nn">matplotlib.mlab</span> <span class="kn">as</span> <span class="nn">mlab</span>

<span class="kn">import</span> <span class="nn">pyradi.rystare</span> <span class="kn">as</span> <span class="nn">rystare</span>
<span class="kn">import</span> <span class="nn">pyradi.ryplot</span> <span class="kn">as</span> <span class="nn">ryplot</span>
<span class="kn">import</span> <span class="nn">pyradi.ryfiles</span> <span class="kn">as</span> <span class="nn">ryfiles</span>
<span class="kn">import</span> <span class="nn">pyradi.ryutils</span> <span class="kn">as</span> <span class="nn">ryutils</span>

<span class="sd">&quot;&quot;&quot;This file provides examples of use of the CcdCmosSim models for a CMOS/CCD photosensor.</span>

<span class="sd">Two models are provided &#39;simple&#39; and &#39;advanced&#39;</span>

<span class="sd">Author: Mikhail V. Konnik, revised/ported by CJ Willers</span>

<span class="sd">Original source: http://arxiv.org/pdf/1412.4031.pdf</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1">#set up the parameters for this run</span>
<span class="n">doPlots</span><span class="o">=</span><span class="bp">True</span>
<span class="n">doHisto</span><span class="o">=</span><span class="bp">True</span>
<span class="n">doImages</span><span class="o">=</span><span class="bp">True</span>
<span class="n">outfilename</span> <span class="o">=</span> <span class="s1">&#39;Output&#39;</span>
<span class="n">pathtoimage</span> <span class="o">=</span> <span class="s1">&#39;W:/MyApps/pyradi/pyradi/data/image-Disk-256-256.hdf5&#39;</span>

<span class="n">doTest</span> <span class="o">=</span> <span class="s1">&#39;Simple&#39;</span>
<span class="n">doTest</span> <span class="o">=</span> <span class="s1">&#39;Advanced&#39;</span>

<span class="k">if</span> <span class="n">doTest</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Simple&#39;</span><span class="p">]:</span>
    <span class="n">prefix</span> <span class="o">=</span> <span class="s1">&#39;PS&#39;</span>
<span class="k">elif</span>  <span class="n">doTest</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Advanced&#39;</span><span class="p">]:</span>
    <span class="n">prefix</span> <span class="o">=</span> <span class="s1">&#39;PA&#39;</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">exit</span><span class="p">(</span><span class="s1">&#39;Undefined test&#39;</span><span class="p">)</span>

<span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="n">cm</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="n">mum</span><span class="p">,</span> <span class="n">nm</span><span class="p">,</span> <span class="n">rad</span><span class="p">,</span> <span class="n">mrad</span><span class="p">]</span> <span class="o">=</span> <span class="n">rystare</span><span class="o">.</span><span class="n">define_metrics</span><span class="p">()</span>

<span class="c1">#open the file to create data structure and store the results, remove if exists</span>
<span class="n">hdffilename</span> <span class="o">=</span> <span class="s1">&#39;{}{}.hdf5&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">outfilename</span><span class="p">)</span>
<span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">hdffilename</span><span class="p">):</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">hdffilename</span><span class="p">)</span>
<span class="n">strh5</span> <span class="o">=</span> <span class="n">ryfiles</span><span class="o">.</span><span class="n">open_HDF</span><span class="p">(</span><span class="n">hdffilename</span><span class="p">)</span>

<span class="c1">#sensor parameters</span>
<span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/SensorType&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;CCD&#39;</span> <span class="c1"># must be in capitals</span>
<span class="c1">#strh5[&#39;rystare/SensorType&#39;] = &#39;CMOS&#39; # must be in capitals</span>

<span class="c1"># full-frame CCD sensors has 100% fil factor (Janesick: &#39;Scientific Charge-Coupled Devices&#39;)</span>
<span class="k">if</span> <span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/SensorType&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;CMOS&#39;</span><span class="p">]:</span>
    <span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/FillFactor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="c1"># Pixel Fill Factor for CMOS photo sensors.</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/FillFactor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="c1"># Pixel Fill Factor for full-frame CCD photo sensors.</span>

<span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/IntegrationTime&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.01</span> <span class="c1"># Exposure/Integration time, [sec].</span>
<span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/ExternalQuantumEff&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.8</span>  <span class="c1"># external quantum efficiency, fraction not reflected.</span>
<span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/QuantumYield&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span> <span class="c1"># number of electrons absorbed per one photon into material bulk</span>
<span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/FullWellElectrons&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2e4</span> <span class="c1"># full well of the pixel (how many electrons can be stored in one pixel), [e]</span>
<span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/SenseResetVref&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">3.1</span> <span class="c1"># Reference voltage to reset the sense node. [V] typically 3-10 V.</span>

<span class="c1">#sensor noise</span>
<span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/SenseNodeGain&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">5e-6</span> <span class="c1"># Sense node gain, A_SN [V/e]</span>

<span class="c1">#source follower</span>
<span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/SourceFollowerGain&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span> <span class="c1"># Source follower gain, [V/V], lower means amplify the noise.</span>

<span class="c1"># Correlated Double Sampling (CDS)</span>
<span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/CDS-Gain&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span> <span class="c1"># CDS gain, [V/V], lower means amplify the noise.</span>

<span class="c1"># Analogue-to-Digital Converter (ADC)</span>
<span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/ADC-Num-bits&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">12.</span> <span class="c1"># noise is more apparent on high Bits</span>
<span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/ADC-Offset&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span> <span class="c1"># Offset of the ADC, in DN</span>

<span class="c1"># Light Noise parameters</span>
<span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/flag/photonshotnoise&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span> <span class="c1">#photon shot noise.</span>
<span class="c1"># photo response non-uniformity noise (PRNU), or also called light Fixed Pattern Noise (light FPN)</span>
<span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/flag/PRNU&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
<span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/noise/PRNU/seed&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">362436069</span>
<span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/noise/PRNU/model&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Janesick-Gaussian&#39;</span>
<span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/noise/PRNU/parameters&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># see matlab filter or scipy lfilter functions for details</span>
<span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/noise/PRNU/factor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.01</span> <span class="c1"># PRNU factor in percent [typically about 1\% for CCD and up to 5% for CMOS];</span>

<span class="c1"># Dark Current Noise parameters</span>
<span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/flag/darkcurrent&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
<span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/OperatingTemperature&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">300.</span> <span class="c1"># operating temperature, [K]</span>
<span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/DarkFigureMerit&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span> <span class="c1"># dark current figure of merit, [nA/cm2].  For very poor sensors, add DFM</span>
<span class="c1">#  Increasing the DFM more than 10 results to (with the same exposure time of 10^-6):</span>
<span class="c1">#  Hence the DFM increases the standard deviation and does not affect the mean value.</span>
<span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/DarkCurrentElecrons&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>  <span class="c1">#to be computed</span>

<span class="c1"># dark current shot noise</span>
<span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/flag/DarkCurrent-DShot&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>

<span class="c1">#dark current Fixed Pattern Noise</span>
<span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/flag/DarkCurrentDarkFPN-Pixel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
<span class="c1"># Janesick&#39;s book: dark current FPN quality factor is typically between 10\% and 40\% for CCD and CMOS sensors</span>
<span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/noise/darkFPN/DN&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.3</span>
<span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/noise/darkFPN/seed&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">362436128</span>
<span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/noise/darkFPN/limitnegative&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span> <span class="c1"># only used with &#39;Janesick-Gaussian&#39;</span>

<span class="k">if</span> <span class="n">doTest</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Simple&#39;</span><span class="p">]:</span>
    <span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/noise/darkFPN/model&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Janesick-Gaussian&#39;</span>
    <span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/noise/darkFPN/parameters&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[];</span>   <span class="c1"># see matlab filter or scipy lfilter functions for details</span>
<span class="k">elif</span>  <span class="n">doTest</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Advanced&#39;</span><span class="p">]:</span>
    <span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/noise/darkFPN/model&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;LogNormal&#39;</span> <span class="c1">#suitable for long exposures</span>
    <span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/noise/darkFPN/parameters&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">]</span> <span class="c1">#first is lognorm_mu; second is lognorm_sigma.</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="c1"># #alternative model</span>
<span class="c1"># strh5[&#39;rystare/noise/darkFPN/model&#39;]  = &#39;Wald&#39;</span>
<span class="c1"># strh5[&#39;rystare/noise/darkFPN/parameters&#39;]  = 2. #small parameters (w&lt;1) produces extremely narrow distribution, large parameters (w&gt;10) produces distribution with large tail.</span>

<span class="c1"># #alternative model</span>
<span class="c1"># strh5[&#39;rystare/noise/darkFPN/model&#39;]  = &#39;AR-ElGamal&#39;</span>
<span class="c1"># strh5[&#39;rystare/noise/darkFPN/parameters&#39;]  = [1., 0.5] # see matlab filter or scipy lfilter functions for details</span>

<span class="c1">#dark current Offset Fixed Pattern Noise</span>
<span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/flag/darkcurrent_offsetFPN&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
<span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/noise/darkFPN_offset/model&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Janesick-Gaussian&#39;</span>
<span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/noise/darkFPN_offset/parameters&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># see matlab filter or scipy lfilter functions for details</span>
<span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/noise/darkFPN_offset/DNcolumn&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0005</span> <span class="c1"># percentage of (V_REF - V_SN)</span>

<span class="c1"># Source Follower VV non-linearity</span>
<span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/flag/VVnonlinearity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>

<span class="c1">#ADC</span>
<span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/flag/ADCnonlinearity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/ADC-Gain&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>

<span class="k">if</span> <span class="n">doTest</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Simple&#39;</span><span class="p">]:</span>
    <span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/flag/sourcefollowernoise&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
<span class="k">elif</span>  <span class="n">doTest</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Advanced&#39;</span><span class="p">]:</span>
<span class="c1">#source follower noise.</span>
    <span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/flag/sourcefollowernoise&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/noise/sf/CDS-SampleToSamplingTime&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-6</span> <span class="c1">#CDS sample-to-sampling time [sec].</span>
    <span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/noise/sf/flickerCornerHz&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e6</span> <span class="c1">#flicker noise corner frequency $f_c$ in [Hz], where power spectrum of white and flicker noise are equal [Hz].</span>
    <span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/noise/sf/dataClockSpeed&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">20e6</span> <span class="c1">#MHz data rate clocking speed.</span>
    <span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/noise/sf/WhiteNoiseDensity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">15e-9</span> <span class="c1">#thermal white noise [\f$V/Hz^{1/2}\f$, typically \f$15 nV/Hz^{1/2}\f$ ]</span>
    <span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/noise/sf/DeltaIModulation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-8</span> <span class="c1">#[A] source follower current modulation induced by RTS [CMOS ONLY]</span>
    <span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/noise/sf/FreqSamplingDelta&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">10000.</span> <span class="c1">#sampling spacing for the frequencies (e.g., sample every 10kHz);</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="c1">#charge to voltage</span>
<span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/flag/Venonlinearity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>

<span class="c1">#sense node reset noise.</span>
<span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/sn/V-FW&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
<span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/sn/V-min&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
<span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/sn/C-SN&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
<span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/flag/SenseNodeResetNoise&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
<span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/noise/sn/ResetKTC-Sigma&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
<span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/noise/sn/ResetFactor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.8</span> <span class="c1"># the compensation factor of the Sense Node Reset Noise:</span>
                                       <span class="c1"># 1 - no compensation from CDS for Sense node reset noise.</span>
                                       <span class="c1"># 0 - fully compensated SN reset noise by CDS.</span>

<span class="c1">#Sensor noises and signal visualisation</span>
<span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/flag/plots/doPlots&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
<span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/flag/plots/plotLogs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
<span class="c1"># strh5[&#39;rystare/flag/plots/irradiance&#39;] = True</span>
<span class="c1"># strh5[&#39;rystare/flag/plots/electrons&#39;] = True</span>
<span class="c1"># strh5[&#39;rystare/flag/plots/volts&#39;] = True</span>
<span class="c1"># strh5[&#39;rystare/flag/plots/DN&#39;] = True</span>
<span class="c1"># strh5[&#39;rystare/flag/plots/SignalLight&#39;] = True</span>
<span class="c1"># strh5[&#39;rystare/flag/plots/SignalDark&#39;] = True</span>

<span class="c1">#For testing and measurements only:</span>
<span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/flag/darkframe&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span> <span class="c1"># True if no signal, only dark</span>

<span class="c1">#=============================================================================</span>

<span class="k">if</span> <span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/flag/darkframe&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>  <span class="c1"># we have zero light illumination</span>
    <span class="n">hdffilename</span> <span class="o">=</span> <span class="s1">&#39;data/image-Zero-256-256.hdf5&#39;</span>
<span class="k">else</span><span class="p">:</span>   <span class="c1"># load an image, nonzero illumination</span>
    <span class="n">hdffilename</span> <span class="o">=</span> <span class="s1">&#39;data/image-Disk-256-256.hdf5&#39;</span>

<span class="k">if</span> <span class="n">pathtoimage</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">pathtoimage</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">__file__</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">hdffilename</span>

<span class="n">imghd5</span> <span class="o">=</span> <span class="n">ryfiles</span><span class="o">.</span><span class="n">open_HDF</span><span class="p">(</span><span class="n">pathtoimage</span><span class="p">)</span>

<span class="c1">#images must be in photon rate irradiance units q/(m2.s)</span>
<span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/SignalPhotonRateIrradiance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">imghd5</span><span class="p">[</span><span class="s1">&#39;image/PhotonRateIrradiance&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>

<span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/pixelPitch&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">imghd5</span><span class="p">[</span><span class="s1">&#39;image/pixelPitch&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
<span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/imageName&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">imghd5</span><span class="p">[</span><span class="s1">&#39;image/imageName&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
<span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/imageSizePixels&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">imghd5</span><span class="p">[</span><span class="s1">&#39;image/imageSizePixels&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>

<span class="c1">#calculate the noise and final images</span>
<span class="n">strh5</span> <span class="o">=</span> <span class="n">rystare</span><span class="o">.</span><span class="n">photosensor</span><span class="p">(</span><span class="n">strh5</span><span class="p">)</span> <span class="c1"># here the Photon-to-electron conversion occurred.</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;{}{}.txt&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span><span class="n">outfilename</span><span class="p">),</span> <span class="s1">&#39;wt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fo</span><span class="p">:</span>
    <span class="n">fo</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;{:25}, {:.5e}, {:.5e}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;SignalPhotonRateIrradiance&#39;</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/SignalPhotonRateIrradiance&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/SignalPhotonRateIrradiance&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">)))</span>
    <span class="n">fo</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;{:25}, {:.5e}, {:.5e}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;signalLight&#39;</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/signalLight&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/signalLight&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">)))</span>
    <span class="n">fo</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;{:25}, {:.5e}, {:.5e}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;signalDark&#39;</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/signalDark&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/signalDark&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">)))</span>
    <span class="n">fo</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;{:25}, {:.5e}, {:.5e}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;source_follower_noise&#39;</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/noise/sf/source_follower_noise&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/noise/sf/source_follower_noise&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">)))</span>
    <span class="n">fo</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;{:25}, {:.5e}, {:.5e}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;SignalPhotons&#39;</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/SignalPhotons&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/SignalPhotons&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">)))</span>
    <span class="n">fo</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;{:25}, {:.5e}, {:.5e}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;SignalElectrons&#39;</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/SignalElectrons&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/SignalElectrons&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">)))</span>
    <span class="n">fo</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;{:25}, {:.5e}, {:.5e}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;SignalVoltage&#39;</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/SignalVoltage&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/SignalVoltage&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">)))</span>
    <span class="n">fo</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;{:25}, {:.5e}, {:.5e}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;SignalDN&#39;</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/SignalDN&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/SignalDN&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">)))</span>

<span class="k">if</span> <span class="n">doPlots</span><span class="p">:</span>
    <span class="n">lstimgs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;rystare/SignalPhotonRateIrradiance&#39;</span><span class="p">,</span><span class="s1">&#39;rystare/SignalPhotons&#39;</span><span class="p">,</span><span class="s1">&#39;rystare/SignalElectrons&#39;</span><span class="p">,</span><span class="s1">&#39;rystare/SignalVoltage&#39;</span><span class="p">,</span>
               <span class="s1">&#39;rystare/SignalDN&#39;</span><span class="p">,</span><span class="s1">&#39;rystare/signalLight&#39;</span><span class="p">,</span><span class="s1">&#39;rystare/signalDark&#39;</span><span class="p">,</span> <span class="s1">&#39;rystare/noise/PRNU/nonuniformity&#39;</span><span class="p">,</span>
               <span class="s1">&#39;rystare/noise/darkFPN/nonuniformity&#39;</span><span class="p">]</span>
    <span class="c1"># ryfiles.plotHDF5Images(strh5, prefix=prefix, colormap=mcm.gray,  lstimgs=lstimgs, logscale=strh5[&#39;rystare/flag/plots/plotLogs&#39;].value)</span>
    <span class="n">ryfiles</span><span class="o">.</span><span class="n">plotHDF5Images</span><span class="p">(</span><span class="n">strh5</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span><span class="p">,</span> <span class="n">colormap</span><span class="o">=</span><span class="n">mcm</span><span class="o">.</span><span class="n">jet</span><span class="p">,</span>  <span class="n">lstimgs</span><span class="o">=</span><span class="n">lstimgs</span><span class="p">,</span> <span class="n">logscale</span><span class="o">=</span><span class="n">strh5</span><span class="p">[</span><span class="s1">&#39;rystare/flag/plots/plotLogs&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

<span class="k">if</span> <span class="n">doHisto</span><span class="p">:</span>
    <span class="n">lstimgs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;rystare/SignalPhotonRateIrradiance&#39;</span><span class="p">,</span><span class="s1">&#39;rystare/SignalPhotons&#39;</span><span class="p">,</span><span class="s1">&#39;rystare/SignalElectrons&#39;</span><span class="p">,</span><span class="s1">&#39;rystare/SignalVoltage&#39;</span><span class="p">,</span>
               <span class="s1">&#39;rystare/SignalDN&#39;</span><span class="p">,</span><span class="s1">&#39;rystare/signalLight&#39;</span><span class="p">,</span><span class="s1">&#39;rystare/signalDark&#39;</span><span class="p">,</span>
               <span class="s1">&#39;rystare/noise/PRNU/nonuniformity&#39;</span><span class="p">,</span><span class="s1">&#39;rystare/noise/darkFPN/nonuniformity&#39;</span><span class="p">]</span>
    <span class="n">ryfiles</span><span class="o">.</span><span class="n">plotHDF5Histograms</span><span class="p">(</span><span class="n">strh5</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">lstimgs</span><span class="o">=</span><span class="n">lstimgs</span><span class="p">)</span>

<span class="k">if</span> <span class="n">doImages</span><span class="p">:</span>
    <span class="n">lstimgs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;rystare/SignalPhotonRateIrradiance&#39;</span><span class="p">,</span><span class="s1">&#39;rystare/SignalPhotonRate&#39;</span><span class="p">,</span> <span class="s1">&#39;rystare/SignalPhotons&#39;</span><span class="p">,</span><span class="s1">&#39;rystare/SignalElectrons&#39;</span><span class="p">,</span><span class="s1">&#39;rystare/SignalVoltage&#39;</span><span class="p">,</span>
                <span class="s1">&#39;rystare/SignalDN&#39;</span><span class="p">,</span><span class="s1">&#39;rystare/signalLight&#39;</span><span class="p">,</span><span class="s1">&#39;rystare/signalDark&#39;</span><span class="p">,</span> <span class="s1">&#39;rystare/noise/sn_reset/noisematrix&#39;</span><span class="p">,</span><span class="s1">&#39;rystare/noise/sf/source_follower_noise&#39;</span><span class="p">,</span>
                <span class="s1">&#39;rystare/noise/PRNU/nonuniformity&#39;</span><span class="p">,</span><span class="s1">&#39;rystare/noise/darkFPN/nonuniformity&#39;</span><span class="p">]</span>
    <span class="n">ryfiles</span><span class="o">.</span><span class="n">plotHDF5Bitmaps</span><span class="p">(</span><span class="n">strh5</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s1">&#39;png&#39;</span><span class="p">,</span> <span class="n">lstimgs</span><span class="o">=</span><span class="n">lstimgs</span><span class="p">)</span>

<span class="n">strh5</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
<span class="n">strh5</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="hdf5-file">
<h2>HDF5 File<a class="headerlink" href="#hdf5-file" title="Permalink to this headline">¶</a></h2>
<p>The Python implementation of the model uses an HDF5 file to capture the
input and output data for record keeping or subsequent analysis.
HDF5 files provide for hierarchical data structures and easy read/save to disk.
See the file <cite>hdf5-as-data-format.md</cite> (<a class="reference internal" href="#hdf5asdataformat" id="id1">[hdf5asdataformat]</a>) in the pyradi root directory for more detail.</p>
<p>Input images are written to and read from HDF5 files as well.  These files store the
image as well as the images&#8217; dimensional scaling in the focal plane.
The intent is to later create test targets with specific spatial
frequencies in these files.</p>
</div>
<div class="section" id="module-pyradi.rystare">
<span id="code-overview"></span><h2>Code Overview<a class="headerlink" href="#module-pyradi.rystare" title="Permalink to this headline">¶</a></h2>
<p>This module provides a high level model for CCD and CMOS staring array 
signal chain modelling. The work is based on a paper and Matlab code by Mikhail Konnik,
available at:</p>
<ul class="simple">
<li>Paper available at: <a class="reference external" href="http://arxiv.org/pdf/1412.4031.pdf">http://arxiv.org/pdf/1412.4031.pdf</a></li>
<li>Matlab code available at: <a class="reference external" href="https://bitbucket.org/aorta/highlevelsensorsim">https://bitbucket.org/aorta/highlevelsensorsim</a></li>
</ul>
<p>See the documentation at <a class="reference external" href="http://nelisw.github.io/pyradi-docs/_build/html/index.html">http://nelisw.github.io/pyradi-docs/_build/html/index.html</a> 
or pyradi/doc/rystare.rst  for more detail.</p>
</div>
<div class="section" id="module-functions">
<h2>Module functions<a class="headerlink" href="#module-functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pyradi.rystare.photosensor">
<code class="descclassname">pyradi.rystare.</code><code class="descname">photosensor</code><span class="sig-paren">(</span><em>strh5</em><span class="sig-paren">)</span><a class="headerlink" href="#pyradi.rystare.photosensor" title="Permalink to this definition">¶</a></dt>
<dd><p>This routine simulates the behaviour of a CCD/CMOS sensor, performing the conversion 
from irradiance to electrons, then volts, and then digital numbers.</p>
<p>The process from incident photons to the digital numbers appeared on the image is outlined. 
First of all, the radiometry is considered. Then, the process of conversion from photons to 
electrons is outlined. Following that, conversion from electrons to voltage is 
described.  Finally, the ADC converts the voltage signal into digital numbers. 
The whole process is depicted on Figure below.</p>
<a class="reference internal image-reference" href="_images/camerascheme-horiz.png"><img alt="camerascheme-horiz.png" class="align-center" src="_images/camerascheme-horiz.png" style="width: 812.0px; height: 244.0px;" /></a>
<p>Many noise sources contribute to the resulting noise image that is produced by
photosensors. Noise sources can be broadly classified as either
<em>fixed-pattern (time-invariant)</em> or <em>temporal (time-variant)</em>
noise. Fixed-pattern noise refers to any spatial pattern that does not change
significantly from frame to frame. Temporal noise, on the other hand, changes
from one frame to the next.</p>
<p>Note that in the sequence below we add signal and noise signals linearly together. 
For uncorrelated noise sources, the noise power values are added in quadrature, but
that does not apply here, because we are adding instantaneous noise values (per pixel)
so that these noise and signal values add linearly.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><div class="first last line-block">
<div class="line">strh5 (hdf5 file): hdf5 file that defines all simulation parameters</div>
</div>
</dd>
<dt>Returns:</dt>
<dd><div class="first last line-block">
<div class="line">in strh5: (hdf5 file) updated data fields</div>
</div>
</dd>
<dt>Raises:</dt>
<dd><div class="first last line-block">
<div class="line">No exception is raised.</div>
</div>
</dd>
</dl>
<p>Author: Mikhail V. Konnik, revised/ported by CJ Willers</p>
<p>Original source: <a class="reference external" href="http://arxiv.org/pdf/1412.4031.pdf">http://arxiv.org/pdf/1412.4031.pdf</a></p>
</dd></dl>

<dl class="function">
<dt id="pyradi.rystare.set_photosensor_constants">
<code class="descclassname">pyradi.rystare.</code><code class="descname">set_photosensor_constants</code><span class="sig-paren">(</span><em>strh5</em><span class="sig-paren">)</span><a class="headerlink" href="#pyradi.rystare.set_photosensor_constants" title="Permalink to this definition">¶</a></dt>
<dd><p>Defining the constants that are necessary for calculation of photon energy, dark current rate, etc.</p>
<blockquote>
<div><dl class="docutils">
<dt>Args:</dt>
<dd><div class="first last line-block">
<div class="line">strh5 (hdf5 file): hdf5 file that defines all simulation parameters</div>
</div>
</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd><div class="first last line-block">
<div class="line">in strh5: (hdf5 file) updated data fields</div>
</div>
</dd>
<dt>Raises:</dt>
<dd><div class="first last line-block">
<div class="line">No exception is raised.</div>
</div>
</dd>
</dl>
<p>Author: Mikhail V. Konnik, revised/ported by CJ Willers</p>
<p>Original source: <a class="reference external" href="http://arxiv.org/pdf/1412.4031.pdf">http://arxiv.org/pdf/1412.4031.pdf</a></p>
</dd></dl>

<dl class="function">
<dt id="pyradi.rystare.check_create_datasets">
<code class="descclassname">pyradi.rystare.</code><code class="descname">check_create_datasets</code><span class="sig-paren">(</span><em>strh5</em><span class="sig-paren">)</span><a class="headerlink" href="#pyradi.rystare.check_create_datasets" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the arrays to store the various image-sized variables.</p>
<blockquote>
<div><dl class="docutils">
<dt>Args:</dt>
<dd><div class="first last line-block">
<div class="line">strh5 (hdf5 file): hdf5 file that defines all simulation parameters</div>
</div>
</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd><div class="first last line-block">
<div class="line">in strh5: (hdf5 file) updated data fields</div>
</div>
</dd>
<dt>Raises:</dt>
<dd><div class="first last line-block">
<div class="line">No exception is raised.</div>
</div>
</dd>
</dl>
<p>Author: Mikhail V. Konnik, revised/ported by CJ Willers</p>
<p>Original source: <a class="reference external" href="http://arxiv.org/pdf/1412.4031.pdf">http://arxiv.org/pdf/1412.4031.pdf</a></p>
</dd></dl>

<dl class="function">
<dt id="pyradi.rystare.source_follower">
<code class="descclassname">pyradi.rystare.</code><code class="descname">source_follower</code><span class="sig-paren">(</span><em>strh5</em><span class="sig-paren">)</span><a class="headerlink" href="#pyradi.rystare.source_follower" title="Permalink to this definition">¶</a></dt>
<dd><p>The amplification of the voltage from Sense Node by Source Follower.</p>
<p>Conventional sensor use a floating-diffusion sense node followed by a
charge-to-voltage amplifier, such as a source follower.</p>
<a class="reference internal image-reference" href="_images/source_follower.png"><img alt="_images/source_follower.png" class="align-center" src="_images/source_follower.png" style="width: 162.3px; height: 237.9px;" /></a>
<p>Source follower is one of basic single-stage field effect transistor (FET)
amplifier topologies that is typically used as a voltage buffer. In such a
circuit, the gate terminal of the transistor serves as the input, the source is
the output, and the drain is common to both input and output. At low
frequencies, the source follower has voltage gain:</p>
<p><img class="math" src="_images/math/083cd4c1ddd9116b10fc4be5779cbd7f5084a5ad.png" alt="{A_{\text{v}}} = \frac{v_{\text{out}}}{v_{\text{in}}} = \frac{g_m R_{\text{S}}}{g_m R_{\text{S}} + 1} \approx 1 \qquad (g_m R_{\text{S}} \gg 1)"/></p>
<p>Source follower is a voltage follower, its gain is less than 1. Source followers
are used to preserve the linear relationship between incident light, generated
photoelectrons and the output voltage.</p>
<p>The V/V non-linearity affect shot noise (but does not affect FPN curve) and can
cause some shot-noise probability density compression. The V/V
non-linearity non-linearity is caused by non-linear response in ADC or source
follower.</p>
<p>The V/V non-linearity can be simulated as a change in source follower gain
<img class="math" src="_images/math/0833f2c86efd74ae1069fc4bb1ea57676774f81f.png" alt="A_{SF}"/> as 
a linear function of signal:</p>
<p><img class="math" src="_images/math/e3640b0664b91d0fafeddad8f4c1de68b30f8fa0.png" alt="A_{SF_{new}} = \alpha \cdot \frac{V_{REF} - S(V_{SF}) }{V_{REF} } + A_{SF},"/></p>
<p>where <img class="math" src="_images/math/9aec9ae51af801cbc6b8c9aa208660b040b43c44.png" alt="\alpha = A_{SF}\cdot\frac{\gamma_{nlr} -1}{ V_{FW} }"/> and
<img class="math" src="_images/math/9c3043ea735874ac1ae7fa17e3465ba1f711a151.png" alt="\gamma_{nlr}"/> is a non-linearity ratio of <img class="math" src="_images/math/0833f2c86efd74ae1069fc4bb1ea57676774f81f.png" alt="A_{SF}"/>. In the simulation
we assume <img class="math" src="_images/math/7e5015dc89922952c22343b6878cbac3796c796f.png" alt="A_{SF} = 1"/> and <img class="math" src="_images/math/0f60543c89ce8513cb2bdf551faae4c187bcc81d.png" alt="\gamma_{nlr} = 1.05"/> i.e. 5% of
non-linearity of <img class="math" src="_images/math/0833f2c86efd74ae1069fc4bb1ea57676774f81f.png" alt="A_{SF}"/>. Then the voltage is multiplied on the new sense
node gain <img class="math" src="_images/math/9bc9e269928f51714f9d9af5ee744714e90df050.png" alt="A_{SF_{new}}"/>:</p>
<p><img class="math" src="_images/math/990ea05156034bb7d42467f64137a9121f8a39b2.png" alt="I_{V} = I_{V}\cdot A_{SF_{new}}"/></p>
<p>After that, the voltage goes to ADC for quantisation to digital numbers.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><div class="first last line-block">
<div class="line">strh5 (hdf5 file): hdf5 file that defines all simulation parameters</div>
</div>
</dd>
<dt>Returns:</dt>
<dd><div class="first last line-block">
<div class="line">in strh5: (hdf5 file) updated data fields</div>
</div>
</dd>
<dt>Raises:</dt>
<dd><div class="first last line-block">
<div class="line">No exception is raised.</div>
</div>
</dd>
</dl>
<p>Author: Mikhail V. Konnik, revised/ported by CJ Willers</p>
<p>Original source: <a class="reference external" href="http://arxiv.org/pdf/1412.4031.pdf">http://arxiv.org/pdf/1412.4031.pdf</a></p>
</dd></dl>

<dl class="function">
<dt id="pyradi.rystare.fixed_pattern_offset">
<code class="descclassname">pyradi.rystare.</code><code class="descname">fixed_pattern_offset</code><span class="sig-paren">(</span><em>strh5</em><span class="sig-paren">)</span><a class="headerlink" href="#pyradi.rystare.fixed_pattern_offset" title="Permalink to this definition">¶</a></dt>
<dd><p>Add dark fixed pattens offset</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><div class="first last line-block">
<div class="line">strh5 (hdf5 file): hdf5 file that defines all simulation parameters</div>
</div>
</dd>
<dt>Returns:</dt>
<dd><div class="first last line-block">
<div class="line">in strh5: (hdf5 file) updated data fields</div>
</div>
</dd>
<dt>Raises:</dt>
<dd><div class="first last line-block">
<div class="line">No exception is raised.</div>
</div>
</dd>
</dl>
<p>Author: Mikhail V. Konnik, revised/ported by CJ Willers</p>
<p>Original source: <a class="reference external" href="http://arxiv.org/pdf/1412.4031.pdf">http://arxiv.org/pdf/1412.4031.pdf</a></p>
</dd></dl>

<dl class="function">
<dt id="pyradi.rystare.cds">
<code class="descclassname">pyradi.rystare.</code><code class="descname">cds</code><span class="sig-paren">(</span><em>strh5</em><span class="sig-paren">)</span><a class="headerlink" href="#pyradi.rystare.cds" title="Permalink to this definition">¶</a></dt>
<dd><p>Reducing the noise by Correlated Double Sampling, but right now the routine just adds the noise.</p>
<p>Correlated Double Sampling (CDS) is a technique for measuring photo voltage
values that removes an undesired noise. The sensor&#8217;s output is measured twice.
Correlated Double Sampling is used for compensation of Fixed pattern
noise caused by dark current leakage,
irregular pixel converters and the like. It appears on the same pixels at
different times when images are taken. It can be suppressed with noise reduction
and on-chip noise reduction technology. The main approach is CDS, having one
light signal read by two circuits.</p>
<p>In CDS, a circuit measures the difference between the reset voltage and the
signal voltage for each pixel, and assigns the resulting value of charge to the
pixel. The additional step of measuring the output node reference voltage before
each pixel charge is transferred makes it unnecessary to reset to the same level
for each pixel.</p>
<p>First, only the noise is read. Next, it is read in combination with the light
signal. When the noise component is subtracted from the combined signal, the
fixed-pattern noise can be eliminated.</p>
<p>CDS is commonly used in image sensors to reduce FPN and reset noise. CDS only
reduces offset FPN (gain FPN cannot be reduced using CDS). CDS in CCDs, PPS,
and photogate APS, CDS reduces reset noise, in photodiode APS it increases it
See Janesick&#8217;s book and especially El Gamal&#8217;s lectures.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><div class="first last line-block">
<div class="line">strh5 (hdf5 file): hdf5 file that defines all simulation parameters</div>
</div>
</dd>
<dt>Returns:</dt>
<dd><div class="first last line-block">
<div class="line">in strh5: (hdf5 file) updated data fields</div>
</div>
</dd>
<dt>Raises:</dt>
<dd><div class="first last line-block">
<div class="line">No exception is raised.</div>
</div>
</dd>
</dl>
<p>Author: Mikhail V. Konnik, revised/ported by CJ Willers</p>
<p>Original source: <a class="reference external" href="http://arxiv.org/pdf/1412.4031.pdf">http://arxiv.org/pdf/1412.4031.pdf</a></p>
</dd></dl>

<dl class="function">
<dt id="pyradi.rystare.adc">
<code class="descclassname">pyradi.rystare.</code><code class="descname">adc</code><span class="sig-paren">(</span><em>strh5</em><span class="sig-paren">)</span><a class="headerlink" href="#pyradi.rystare.adc" title="Permalink to this definition">¶</a></dt>
<dd><p>An analogue-to-digital converter (ADC) transforms a voltage signal into discrete codes.</p>
<p>An analogue-to-digital converter (ADC) transforms a voltage signal into discrete
codes. An <img class="math" src="_images/math/f4170ed8938b79490d8923857962695514a8e4cb.png" alt="N"/>-bit ADC has <img class="math" src="_images/math/81e79f244ba3a8a833d8b0edcd320d3efe352660.png" alt="2^N"/> possible output codes with the difference between code
being <img class="math" src="_images/math/cc305898fc033bf2cc0b1d35bd0c1886902a98aa.png" alt="V_{ADC.REF}/2^N"/>. The resolution of the ADC indicates the number of
discrete values that can be produced over the range of analogue values and can
be expressed as:</p>
<p><img class="math" src="_images/math/e00958a6db6ae8f8fb8789c64ddf3ea2f4bdf170.png" alt="K_{ADC} = \frac{V_{ADC.REF} - V_\mathrm {min}}{N_{max}}"/>
where <img class="math" src="_images/math/e8f114537eb2970794620ed26ef6bbc06c0af1dd.png" alt="V_\mathrm{ADC.REF}"/> is the maximum voltage that can be quantified,
<img class="math" src="_images/math/c6b8e7525da365d5c1a187ba7a2a1818ac1aff04.png" alt="V_{min}"/> is minimum quantifiable voltage, and <img class="math" src="_images/math/6536bc52bfb15af6fd8e9e7b9dbf0fe97ca45ce2.png" alt="N_{max} = 2^N"/> is the number of
voltage intervals. Therefore, the output of an ADC can be represented as:</p>
<p><img class="math" src="_images/math/fe8cc9dfc73834addbc77c051d39c04b9af434bb.png" alt="ADC_{Code} = \textrm{round}\left( \frac{V_{input}-V_{min}}{K_{ADC}} \right)"/></p>
<p>The lower the reference voltage <img class="math" src="_images/math/073943197c7efc3d8bce7072af7abced5e6e0ccf.png" alt="V_{ADC.REF}"/>, the smaller the range of the
voltages one can measure.</p>
<p>After the electron matrix has been converted to voltages, the sense node reset
noise and offset FPN noise are  added, the V/V gain non-linearity is applied (if
desired), the ADC non-linearity is applied (if necessary). Finally the result is
multiplied by ADC gain and rounded to produce the signal as a digital number:</p>
<p><img class="math" src="_images/math/7380923062eb34a15f938837ac596616739a9eb9.png" alt="I_{DN} =  \textrm{round} (A_{ADC}\cdot I_{total.V}),"/></p>
<p>where <img class="math" src="_images/math/448b7d52ff5a14ec81dfa6a3c4a6130c9c0e8fce.png" alt="I_\textrm{total.V} = (V_{ADC.REF} - I_{V})"/> is the total voltage signal
accumulated during one frame acquisition, <img class="math" src="_images/math/073943197c7efc3d8bce7072af7abced5e6e0ccf.png" alt="V_{ADC.REF}"/> is the maximum voltage
that can be quantified by an ADC, and <img class="math" src="_images/math/4cbb12bc2bdd25fa3bafea251b53f55941c140ff.png" alt="I_V"/> is the total voltage signal
accumulated by the end of the exposure (integration) time and conversion.
Usually <img class="math" src="_images/math/1b01f164b4f123d98ba9040dc5fa3a52892e1eba.png" alt="I_V = I_{SN.V}"/> after the optional V/V non-linearity is applied. In
this case, the conversion from voltages to digital signal is linear. The
adcnonlinearity &#8220;non-linear ADC case is considered below&#8221;.</p>
<p>In terms of the ADC, the following non-linearity and noise should be considered
for the simulations of the photosensors: Integral Linearity Error, Differential
Linearity Error, quantisation error, and ADC offset.</p>
<p>The DLE indicates the deviation from the ideal 1 LSB (Least Significant Bit)
step size of the analogue input signal corresponding to a code-to-code
increment. Assume that the voltage that corresponds to a step of 1 LSB is
<img class="math" src="_images/math/249793e5016b971f3754696bdf961f383d441aad.png" alt="V_{LSB}"/>. In the ideal case, a change in the input voltage of <img class="math" src="_images/math/249793e5016b971f3754696bdf961f383d441aad.png" alt="V_{LSB}"/> causes
a change in the digital code of 1 LSB. If an input voltage that is more than
<img class="math" src="_images/math/249793e5016b971f3754696bdf961f383d441aad.png" alt="V_{LSB}"/> is required to change a digital code by 1 LSB, then the ADC has DLE
error. In this case, the digital output remains constant when the input
voltage changes from, for example, <img class="math" src="_images/math/760b95b175b1223357d157ef25665b4f0883e8da.png" alt="2 V_{LSB}"/>  to  <img class="math" src="_images/math/8ad0626e5535482434773d8e88c9519d41d04bb4.png" alt="4 V_{LSB}"/>, therefore
corresponding the digital code can never appear at the output. That is, that
code is missing.</p>
<a class="reference internal image-reference" href="_images/dle.png"><img alt="_images/dle.png" class="align-center" src="_images/dle.png" style="width: 544.0px; height: 317.2px;" /></a>
<p>In the illustration above, each input step should be precisely 1/8 of reference
voltage. The first code transition from 000 to 001 is caused by an input change
of 1 LSB as it should be. The second transition, from 001 to 010, has an input
change that is 1.2 LSB, so is too large by 0.2 LSB. The input change for the
third transition is exactly the right size. The digital output remains
constant when the input voltage changes from 4 LSB to 5 LSB, therefore the code
101 can never appear at the output.</p>
<p>The ILE is the maximum deviation of the input/output characteristic from a
straight line passed through its end points. For each voltage in the ADC input,
there is a corresponding code at the ADC output. If an ADC transfer function is
ideal, the steps are perfectly superimposed on a line. However, most real ADC&#8217;s
exhibit deviation from the straight line, which can be expressed in percentage
of the reference voltage or in LSBs. Therefore, ILE is a measure of the
straightness of the transfer function and can be greater than the differential
non-linearity. Taking the ILE into account is important because it cannot be
calibrated out.</p>
<a class="reference internal image-reference" href="_images/ILE.png"><img alt="_images/ILE.png" class="align-center" src="_images/ILE.png" style="width: 544.0px; height: 286.0px;" /></a>
<p>For each voltage in the ADC input there is a corresponding word at the ADC
output. If an ADC is ideal, the steps are perfectly superimposed on a line. But
most of real ADC exhibit deviation from the straight line, which can be
expressed in percentage of the reference voltage or in LSBs.</p>
<p>In our model, we simulate the Integral Linearity Error (ILE) of the ADC as a
dependency of ADC gain <img class="math" src="_images/math/22e52a5af1f2ed71b2a66d57e84ef6f0e67e07eb.png" alt="A_{ADC.linear}"/> on the signal value. Denote
<img class="math" src="_images/math/bbc4dd80ef68bffd37c4037b596fcedc823e81f0.png" alt="\gamma_{ADC.nonlin}"/> as an ADC non-linearity ratio (e.g., <img class="math" src="_images/math/0b60b44d06b03a909898a025030dd53766885830.png" alt="\gamma_{ADC.nonlin}
= 1.04"/>). The linear ADC gain can be calculated from Eq.~ref{eq:kadc} as
<img class="math" src="_images/math/281f45f37ec3cacf6738741d9c10e86ff6be749c.png" alt="A_{ADC} = 1/K_{ADC}"/> and used as <img class="math" src="_images/math/22e52a5af1f2ed71b2a66d57e84ef6f0e67e07eb.png" alt="A_{ADC.linear}"/>. The non-linearity
coefficient <img class="math" src="_images/math/82e49a736706eb6d6864b67107c82127e6074ce6.png" alt="\alpha_{ADC}"/> is calculated as:</p>
<p><img class="math" src="_images/math/a0adf4c439a4928d1f73218142e84771ea361e93.png" alt="\alpha_{ADC} = \frac{1}{V_{ADC.REF}} \left( \frac{ \log(\gamma_{ADC.nonlin}
\cdot A_{ADC.linear} )}{\log(A_{ADC.linear})} - 1 \right)"/></p>
<p>where <img class="math" src="_images/math/e8f114537eb2970794620ed26ef6bbc06c0af1dd.png" alt="V_\mathrm{ADC.REF}"/> is the maximum voltage that can be quantified by an
ADC:</p>
<p><img class="math" src="_images/math/c2deeca67ea01716f8138a02d402437fc324fa46.png" alt="A_{ADC.nonlin} = A_{ADC.linear}^{1-\alpha_{ADC} I_{total.V}},"/></p>
<p>where <img class="math" src="_images/math/22e52a5af1f2ed71b2a66d57e84ef6f0e67e07eb.png" alt="A_{ADC.linear}"/> is the linear ADC gain. The new non-linear ADC conversion
gain <img class="math" src="_images/math/0439beb163dfcc695f89f70b0899ab406bbce16f.png" alt="A_{ADC.nonlin}"/> is then used for the simulations.</p>
<p>Quantisation errors are caused by the rounding, since an ADC has a
finite precision. The probability distribution of quantisation noise is
generally assumed to be uniform. Hence we use the uniform distribution to model
the rounding errors.</p>
<p>It is assumed that the quantisation error is uniformly distributed between -0.5
and +0.5 of the LSB and uncorrelated with the signal.  Denote <img class="math" src="_images/math/c16f2f4d56b7024fd1b9e9a38f40d593d893a4ba.png" alt="q_{ADC}"/> the
quantising step of the ADC. For the ideal DC, the quantisation noise is:</p>
<blockquote>
<div><img class="math" src="_images/math/039c9e650e61a85555767d01961a5132e6ca81f5.png" alt="\sigma_{ADC} = \sqrt{ \frac{q_{ADC}^2 }{12}}."/></div></blockquote>
<p>If <img class="math" src="_images/math/9201ab94a279c9f4a0849997b81fd657d7734184.png" alt="q_{ADC} = 1"/> then the quantisation noise is <img class="math" src="_images/math/0f05ba952ff283b49bcae50f4a19b9f2c2d1451e.png" alt="\sigma_{ADC} = 0.29"/> DN. The
quantisation error has a uniform distribution. We do not assume any particular
architecture of the ADC in our high-level sensor model.
This routine performs analogue-to-digital convertation of volts to DN.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><div class="first last line-block">
<div class="line">strh5 (hdf5 file): hdf5 file that defines all simulation parameters</div>
</div>
</dd>
<dt>Returns:</dt>
<dd><div class="first last line-block">
<div class="line">in strh5: (hdf5 file) updated data fields</div>
</div>
</dd>
<dt>Raises:</dt>
<dd><div class="first last line-block">
<div class="line">No exception is raised.</div>
</div>
</dd>
</dl>
<p>Author: Mikhail V. Konnik, revised/ported by CJ Willers</p>
<p>Original source: <a class="reference external" href="http://arxiv.org/pdf/1412.4031.pdf">http://arxiv.org/pdf/1412.4031.pdf</a></p>
</dd></dl>

<dl class="function">
<dt id="pyradi.rystare.charge_to_voltage">
<code class="descclassname">pyradi.rystare.</code><code class="descname">charge_to_voltage</code><span class="sig-paren">(</span><em>strh5</em><span class="sig-paren">)</span><a class="headerlink" href="#pyradi.rystare.charge_to_voltage" title="Permalink to this definition">¶</a></dt>
<dd><p>The charge to voltage conversion occurs inside this routine</p>
<blockquote>
<div>V/e nonlinearity is small for CCD detetors, but can be very high for some CMOS
architectures (up to 200%) [from Janesick p87]</div></blockquote>
<p>A new matrix strh5[&#8216;rystare/signal/voltage&#8217;] is created and the raw 
voltage signal is stored.</p>
<p>After the charge is generated in the pixel by photo-effect, it is moved
row-by-row to the sense amplifier that is separated from the pixels in case of
CCD. The packets of charge are being shifted to the output sense node,
where electrons are converted to voltage. The typical sense node region is
presented on Figure below.</p>
<a class="reference internal image-reference" href="_images/CCD-sensenoderegion.png"><img alt="_images/CCD-sensenoderegion.png" class="align-center" src="_images/CCD-sensenoderegion.png" style="width: 406.0px; height: 348.5px;" /></a>
<p>Sense node is the final collecting point at the end of the horizontal
register of the CCD sensor. The CCD pixels are made with MOS devices used as
reverse biased capacitors. The charge is readout by a MOSFET based charge to
voltage amplifier. The output voltage is inversely proportional to the sense
node capacitor. Typical example is that the sense node capacitor of the order
<img class="math" src="_images/math/f5b6734504a9d4dc62dc0b25c96fa3ef409d9c65.png" alt="50fF"/>, which produces a gain of <img class="math" src="_images/math/df47a4b8af98c3ba691aa771e24c0fa74b1dd4b4.png" alt="3.2 \mu V/ e^-"/>. It is also important
to minimize the noise of the output amplifier, textbf{typically the largest
noise source in the system}. Sense node converts charge to voltage with typical
sensitivities <img class="math" src="_images/math/d8c8e06e2734ee2d84e1d3ef66091236e55ba894.png" alt="1\dots 4 \mu V/e^-"/>.</p>
<p>The charge collected in each pixel of a sensor array is converted to voltage
by  sense capacitor  and  source-follower amplifier.</p>
<p>Reset noise is induced during such conversion. Prior to the measurement
of each pixel&#8217;s charge, the CCD sense capacitor is reset to a reference level.
Sense node converts charge to voltage with typical sensitivities <img class="math" src="_images/math/d8c8e06e2734ee2d84e1d3ef66091236e55ba894.png" alt="1\dots 4 \mu V/e^-"/>. 
The charge collected in each pixel of a sensor array is converted to
voltage by sense capacitor and source-follower amplifier. 
Reset noise is induced during such conversion. Prior to the measurement of each
pixel&#8217;s charge, the CCD sense node capacitor is reset to a reference level.</p>
<p>Sense Node gain non-linearity, or V/e non-linearity</p>
<p>The V/<img class="math" src="_images/math/a11da7a89c53957a29a0f37e0e81f46c8fb3b581.png" alt="e^-"/> non-linearity affect both FPN and shot noise and can cause
some shot-noise probability density compression. This type of non-linearity is
due to sense node gain non-linearity. Then sense node sensitivity became
non-linear (see Janesick&#8217;s book):</p>
<p><img class="math" src="_images/math/eadfbd531ee7e80a2a148af7ced7808d0677603c.png" alt="S_{SN} ( V_{SN}/e^- ) = \frac{S(V_{SN}) }{(k_1/q)  \ln( V_{REF}/[V_{REF} - S(V_{SN})] )}"/></p>
<p>The V/<img class="math" src="_images/math/a11da7a89c53957a29a0f37e0e81f46c8fb3b581.png" alt="e^-"/> non-linearity can be expressed as  a non-linear dependency of
signals in electron and a sense-node voltage:</p>
<p><img class="math" src="_images/math/f9d21af9486cbbad564048bbd66c5b982edc548b.png" alt="S[e^-] = \frac{k1}{q} \ln \left[ \frac{V_{REF}}{ V_{REF} -  S(V_{SN}) } \right]"/></p>
<p>The V/<img class="math" src="_images/math/a11da7a89c53957a29a0f37e0e81f46c8fb3b581.png" alt="e^-"/> non-linearity affects photon shot noise and skews the
distribution, however this is a minor effect. The V/<img class="math" src="_images/math/a11da7a89c53957a29a0f37e0e81f46c8fb3b581.png" alt="e^-"/> non-linearity can
also be thought as a sense node capacitor non-linearity: when a small signal is
measured, <img class="math" src="_images/math/d3ee53b1baf2655a5f360582bf351e805ddb0f63.png" alt="C_{SN}"/> is fixed or changes negligible; on the other hand,
<img class="math" src="_images/math/4670696c3367a35012ccfdb325d710ac898bcf56.png" alt="C_SN"/> changes significantly and that can affect the signal being
measured.</p>
<p>For the simulation purpose, the V/<img class="math" src="_images/math/a11da7a89c53957a29a0f37e0e81f46c8fb3b581.png" alt="e^-"/> non-linearity can be expressed as:</p>
<p><img class="math" src="_images/math/5c80959cac473b891325106b598a6381d08cbbfc.png" alt="V_{SN} = V_{REF} - S(V_{SN}) = V_{REF}\exp\left[ - \frac{\alpha\cdot S[e^-]\cdot q }{k1} \right]"/></p>
<p>where <img class="math" src="_images/math/6a385f2253ff4b58bfd0c3c8c3267c84e271d823.png" alt="k1=10.909*10^{-15}"/> and <img class="math" src="_images/math/620a3ce6403ec82f1347af9985bc03f7a9382f4a.png" alt="q"/> is the charge of an electron, and <img class="math" src="_images/math/877d234f4cec6974ce218fc2e975a486a7972dfd.png" alt="\alpha"/> is the coefficient of 
non-linearity strength.  The capacitance is given by C =  k1/V</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><div class="first last line-block">
<div class="line">strh5 (hdf5 file): hdf5 file that defines all simulation parameters</div>
</div>
</dd>
<dt>Returns:</dt>
<dd><div class="first last line-block">
<div class="line">in strh5: (hdf5 file) updated data fields</div>
</div>
</dd>
<dt>Raises:</dt>
<dd><div class="first last line-block">
<div class="line">No exception is raised.</div>
</div>
</dd>
</dl>
<p>Author: Mikhail V. Konnik, revised/ported by CJ Willers</p>
<p>Original source: <a class="reference external" href="http://arxiv.org/pdf/1412.4031.pdf">http://arxiv.org/pdf/1412.4031.pdf</a></p>
</dd></dl>

<dl class="function">
<dt id="pyradi.rystare.sense_node_reset_noise">
<code class="descclassname">pyradi.rystare.</code><code class="descname">sense_node_reset_noise</code><span class="sig-paren">(</span><em>strh5</em><span class="sig-paren">)</span><a class="headerlink" href="#pyradi.rystare.sense_node_reset_noise" title="Permalink to this definition">¶</a></dt>
<dd><p>This routine calculates the noise standard deviation for the sense node reset noise.</p>
<p>Sense node Reset noise (kTC noise)</p>
<p>Prior to the measurement of each pixel&#8217;s charge packet, the sense node capacitor
is reset to a reference voltage level. Noise is generated at the sense node by
an uncertainty in the reference voltage level due to thermal variations in the
channel resistance of the MOSFET reset transistor. The reference level of the
sense capacitor is therefore different from pixel to pixel.</p>
<p>Because reset noise can be significant (about 50 rms electrons), most
high-performance photosensors incorporate a noise-reduction mechanism such as
correlated double sampling (CDS).</p>
<p>kTC noise occurs in CMOS sensors, while for CCD sensors the sense
node reset noise is removed~ (see Janesick&#8217;s book) by Correlated Double
Sampling (CDS). Random fluctuations of charge on the sense node during the reset
stage result in a corresponding photodiode reset voltage fluctuation. The sense
node reset noise (in volt units) is given by:</p>
<p><img class="math" src="_images/math/bd3bdbb111514c8ec078622a8e877558de6dee61.png" alt="\sigma_{RESET}=\sqrt{\frac{k_B T}{C_{SN}}}"/></p>
<p>By the relationship Q=CV it can be shown that the kTC noise can be expressed 
as electron count by</p>
<p><img class="math" src="_images/math/fb8ce3cb4f0d276fbe24b11611b601695a31edf9.png" alt="\sigma_{RESET}=\sqrt{\frac{k_B T C_{SN}}{q}}"/></p>
<p>see also <a class="reference external" href="https://en.wikipedia.org/wiki/Johnson%E2%80%93Nyquist_noise">https://en.wikipedia.org/wiki/Johnson%E2%80%93Nyquist_noise</a></p>
<p>The simulation of the sense node reset noise may be performed as an addition of
non-symmetric probability distribution to the reference voltage <img class="math" src="_images/math/0c6eae876f588b2fabd8e1748e5a59909a1cc04a.png" alt="V_{REF}"/>.
However, the form of distribution depends on the sensor&#8217;s architecture and the
reset technique. An Inverse-Gaussian distribution can be
used for the simulation of kTC noise that corresponds to a hard reset technique
in the CMOS sensor, and the Log-Normal distribution can be used for soft-reset
technique. The sense node reset noise can be simulated for each <img class="math" src="_images/math/c07d7ddf20cb31710d4f0e8022b1822fc60ae9bc.png" alt="(i,j)"/>-th pixel
for the soft-reset case as:</p>
<p><img class="math" src="_images/math/621c0d1213b88f4059a6f73de820a9fba45f93b6.png" alt="I_{SN.reset.V}=ln\mathcal{N}(0,\sigma_{RESET}^2)"/></p>
<p>then added to the matrix <img class="math" src="_images/math/014afe386fab4f1436deb2c28502527e9e79377f.png" alt="I_{REF.V}"/> in Volts that corresponds to the reference voltage.</p>
<p>Note: For CCD, the sense node reset noise is entirely removed by CDS.</p>
<p>Note: In CMOS photosensors, it is difficult to remove the reset noise for the specific CMOS pixels 
architectures even after application of CDS. Specifically, the difficulties
arise in &#8216;rolling shutter&#8217; and &#8216;snap&#8217; readout modes.
The reset noise is increasing after CDS by a factor of <img class="math" src="_images/math/a5b72efcff1c09be039a9786d0772d98ad2ac984.png" alt="\sqrt{2}"/>.
Elimination of reset noise in CMOS is quite challenging.</p>
<blockquote>
<div><dl class="docutils">
<dt>Args:</dt>
<dd><div class="first last line-block">
<div class="line">strh5 (hdf5 file): hdf5 file that defines all simulation parameters</div>
</div>
</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd><div class="first last line-block">
<div class="line">in strh5: (hdf5 file) updated data fields</div>
</div>
</dd>
<dt>Raises:</dt>
<dd><div class="first last line-block">
<div class="line">No exception is raised.</div>
</div>
</dd>
</dl>
<p>Author: Mikhail V. Konnik, revised/ported by CJ Willers</p>
<p>Original source: <a class="reference external" href="http://arxiv.org/pdf/1412.4031.pdf">http://arxiv.org/pdf/1412.4031.pdf</a></p>
</dd></dl>

<dl class="function">
<dt id="pyradi.rystare.dark_current_and_dark_noises">
<code class="descclassname">pyradi.rystare.</code><code class="descname">dark_current_and_dark_noises</code><span class="sig-paren">(</span><em>strh5</em><span class="sig-paren">)</span><a class="headerlink" href="#pyradi.rystare.dark_current_and_dark_noises" title="Permalink to this definition">¶</a></dt>
<dd><p>This routine for adding dark current signals and noise, including dark FPN and dark shot noise.</p>
<p>This model is taken from Janesick&#8217;s &#8216;Photon Transfer&#8217; book, page 168, which in turn is taken from
Janesick&#8217;s &#8216;Scientific Charge-Coupled Devices&#8217; book, page 622.</p>
<p>The dark signal is calculated for all pixels in the model. It is implemented using <cite>ones</cite> function in 
MATLAB as a matrix of the same size as the simulated photosensor. For each <img class="math" src="_images/math/c07d7ddf20cb31710d4f0e8022b1822fc60ae9bc.png" alt="(i,j)"/>-th pixel we have:</p>
<p><img class="math" src="_images/math/36379d960b4d07f16a2f7477f5da84cf97e6281f.png" alt="I_{dc.e^-} = t_I\cdot D_R,"/></p>
<p>where <img class="math" src="_images/math/d4eee146f2ea75afc1a838391089e437ad6d5466.png" alt="D_R"/> is the average dark current (originally derived for silicon):</p>
<p><img class="math" src="_images/math/60a3326c129434419558d14bb8d00929917ae04c.png" alt="D_R = 2.55\cdot10^{15}P_A D_{FM} T^{1.5} \exp\left[-\frac{E_{gap}}{2\cdot k\cdot T}\right],"/></p>
<p>where:
<img class="math" src="_images/math/d4eee146f2ea75afc1a838391089e437ad6d5466.png" alt="D_R"/> is in units of [e<sup>-1</sup>/s],
<img class="math" src="_images/math/eca870c3beafdfcea0fd7a8ad7e1de3cbde49640.png" alt="P_A"/> is the pixel&#8217;s area [cm<sup>2</sup>];
<img class="math" src="_images/math/71bd9b46fff5b0fd3cf231f3a99c341d3b21bade.png" alt="D_{FM}"/> is the dark current figure-of-merit in units of [nA/cm<sup>2</sup>] at 300K, 
varies significantly with detector material and  sensor manufacturer, and used in this simulations 
as 0.5 nA/cm<sup>2</sup> for silicon;
<img class="math" src="_images/math/052271cd829c23836b33514b000c20f55f9be9d1.png" alt="E_{gap}"/> is the bandgap energy of the semiconductor which also varies with temperature;
<img class="math" src="_images/math/0b7c1e16a3a8a849bb8ffdcdbf86f65fd1f30438.png" alt="k"/> is Boltzman&#8217;s constant that is <img class="math" src="_images/math/4b9dee621590bb90ebbb876275c51d86641c89f1.png" alt="8.617\cdot10^{-5} [eV/K]."/></p>
<p>The relationship between band gap energy and temperature can be described by Varshni&#8217;s empirical expression,</p>
<p><img class="math" src="_images/math/fe529d02c841b83d8f9e677911e2fd798732d021.png" alt="E_{gap}(T)=E_{gap}(0)-\frac{\alpha T^2}{T+\beta},"/></p>
<p>where <img class="math" src="_images/math/006c7bc4ad3d670f84cdf1bb5fd67000c95d0a72.png" alt="E_{gap}(0)"/>, <img class="math" src="_images/math/877d234f4cec6974ce218fc2e975a486a7972dfd.png" alt="\alpha"/> and <img class="math" src="_images/math/410a9d0df9c135dd73b269cba7ef04dcfd932b1f.png" alt="\beta"/> are material constants. The energy bandgap of 
semiconductors tends to decrease as the temperature is increased. This behaviour can be better understood 
if one considers that the inter-atomic spacing increases when the amplitude of the atomic vibrations 
increases due to the increased thermal energy. This effect is quantified by the linear expansion 
coefficient of a material.</p>
<dl class="docutils">
<dt>For the Silicon: <img class="math" src="_images/math/83ae0ae42ebf9ca70d6926d0c35119e8f63439d7.png" alt="E_{gap}(0) = 1.1557 [eV]"/>, <img class="math" src="_images/math/4ee7ad9fc039d6e91d9c84fb4b8bc22112fed83f.png" alt="\alpha = 7.021*10^{-4}"/> [eV/K], and</dt>
<dd><img class="math" src="_images/math/c6fee0fdd3e8479925d8d30147957dad4f4b1b97.png" alt="\beta = 1108"/> [K].</dd>
<dt>It appears that fill factor does not apply to dark noise (Janesick book p168 and Konnik&#8217;s code</dt>
<dd>does not show this).</dd>
</dl>
<p>According to Janesick&#8217;s Photon transfer book p169 the dark current FPN standard deviation is around 
10% (CCD) and 40% (CMOS) of the dark current. Note that &#8216;dark&#8217; FPN (DN) is much greater than &#8216;light&#8217; 
FPN (PN) by approximately 10 to 40 times.</p>
<blockquote>
<div><dl class="docutils">
<dt>Args:</dt>
<dd><div class="first last line-block">
<div class="line">strh5 (hdf5 file): hdf5 file that defines all simulation parameters</div>
</div>
</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd><div class="first last line-block">
<div class="line">in strh5: (hdf5 file) updated data fields, current in nA</div>
</div>
</dd>
<dt>Raises:</dt>
<dd><div class="first last line-block">
<div class="line">No exception is raised.</div>
</div>
</dd>
</dl>
<p>Author: Mikhail V. Konnik, revised/ported by CJ Willers</p>
<p>Original source: <a class="reference external" href="http://arxiv.org/pdf/1412.4031.pdf">http://arxiv.org/pdf/1412.4031.pdf</a></p>
</dd></dl>

<dl class="function">
<dt id="pyradi.rystare.source_follower_noise">
<code class="descclassname">pyradi.rystare.</code><code class="descname">source_follower_noise</code><span class="sig-paren">(</span><em>strh5</em><span class="sig-paren">)</span><a class="headerlink" href="#pyradi.rystare.source_follower_noise" title="Permalink to this definition">¶</a></dt>
<dd><p>The source follower noise routine, calculates noise in volts.</p>
<p>The pixel&#8217;s source follower noise limits the read noise, however in high-end CCD and CMOS cameras the source 
follower noise has been driven down to one electron rms.
Pixel source follower MOSFET noise consists of three types of noise:
-  white noise;
-  flicker noise;
-  random telegraph noise (RTS).
Each type of noise has its own physics that will be briefly sketched below.</p>
<p><em>Johnson noise (white noise)</em></p>
<p>Similarly to the reset noise in sense node, the source-follower amplifier MOSFET has a resistance that 
generates thermal noise whose value is governed by the Johnson white noise equation. 
It is therefore either referred to as Johnson noise or simply as white noise, since its magnitude is independent of frequency.
If the effective resistance is considered to be the output impedance of the source-follower amplifier, the white noise, 
in volts, is determined by the following equation:</p>
<p><img class="math" src="_images/math/3c6ac4d7895e1bfeb5526bf1683880d33d041a06.png" alt="N_{white} (V_{SF}) = \sqrt{4kTBR_{SF}}"/></p>
<p>where <img class="math" src="_images/math/0b7c1e16a3a8a849bb8ffdcdbf86f65fd1f30438.png" alt="k"/> is Boltzmann&#8217;s constant (J/K), <img class="math" src="_images/math/f2d283a2071f9d043c9e0b0f794a8880fa0d3ce9.png" alt="T"/> is temperature [K], <img class="math" src="_images/math/9805f44feec6f81d376d09e88b8236635edbb3c8.png" alt="B"/> refers to the noise power bandwidth [Hz], 
and <img class="math" src="_images/math/ee6f06f8cd520b992b781e0106a4093af1bcc7e6.png" alt="R_{SF}"/> is the output impedance of the source-follower amplifier.</p>
<p><em>Flicker noise</em></p>
<p>The flicker noise is commonly referred to as <img class="math" src="_images/math/f4c07f414fb7485513e20cb4f89fa649e76a30f2.png" alt="1/f"/> noise because of its approximate inverse dependence on frequency.
For cameras in which pixels are read out at less than approximately 1 megahertz, and with a characteristic <img class="math" src="_images/math/f4c07f414fb7485513e20cb4f89fa649e76a30f2.png" alt="1/f"/> noise 
spectrum, the read noise floor is usually determined by 1/f noise. Note that the noise continues to decrease at this 
rate until it levels off, at a frequency referred to as the <img class="math" src="_images/math/f4c07f414fb7485513e20cb4f89fa649e76a30f2.png" alt="1/f"/> corner frequency. For the typical MOSFET 
amplifier, the white noise floor occurs at approximately 4.5  <img class="math" src="_images/math/e5865f1cf65fad4921fe50d9d88f49ff9fb891c7.png" alt="nV/Hz^{1/2}"/>.</p>
<p>Prominent sources of <img class="math" src="_images/math/f4c07f414fb7485513e20cb4f89fa649e76a30f2.png" alt="1/f"/> noise in an image sensor are pink-coloured noise generated in the photo-diodes and 
the low-bandwidth analogue operation of MOS transistors due to imperfect contacts between two 
materials. Flicker noise is generally accepted to originate due to the existence of interface states in the image sensor 
silicon that turn on and off randomly according to different time constants. All systems exhibiting 1/f behaviour 
have a similar collection of randomly-switching states. In the MOSFET, the states are traps at the silicon-oxide 
interface, which arise because of disruptions in the silicon lattice at the surface. The level of <img class="math" src="_images/math/f4c07f414fb7485513e20cb4f89fa649e76a30f2.png" alt="1/f"/> noise 
in a CCD sensor depends on the pixel sampling rate and from certain crystallographic orientations of silicon 
wafer.</p>
<p><em>Random Telegraph Signal (RTS) noise</em></p>
<p>As the CCD and CMOS pixels are shrinking in dimensions, the low-frequency noise increases. 
In such devices, the low-frequency noise performance is dominated by Random Telegraph Signals (RTS) on top 
of the 1/f noise. The origin of such an RTS is attributed to the random trapping and de-trapping of mobile charge carriers 
in traps located in the oxide or at the interface. The RTS is observed in MOSFETs as a fluctuation in the drain 
current. A pure two-level RTS is represented in the frequency domain by a Lorentzian spectrum.</p>
<p>Mathematically the source follower&#8217;s noise power spectrum can be described as:
<img class="math" src="_images/math/56350f31c6bf2e17b209eea9d3290df7a75d326e.png" alt="S_{SF}(f) = W(f)^2 \cdot \left(1 + \frac{f_c}{f}\right)+S_{RTS}(f),"/></p>
<p>where <img class="math" src="_images/math/df5f8982b6e4cc72e20d950e773ad1294c668d7e.png" alt="W(f)"/> is the thermal white noise [<img class="math" src="_images/math/798918f0bf1c90c0a2369359382e8facb8b87214.png" alt="V/Hz^{1/2}"/>, typically <img class="math" src="_images/math/d08db9802f931e0f0cd8ddc3d75102389b44da91.png" alt="15 nV/Hz^{1/2}"/> ], flicker noise 
corner frequency <img class="math" src="_images/math/7cf208c7b41e8dae38006e68b0b04347b0204b94.png" alt="f_c"/> in [Hz] (flicker noise corner frequency is the frequency where power spectrum of white and flicker noise are equal),
and the RTS power spectrum is given (see Janesick&#8217;s book):</p>
<p><img class="math" src="_images/math/ec2780fad27f76d1c9d3230a92bb7c570092aafb.png" alt="S_{RTS}(f) = \frac{2\Delta I^2 \tau_{RTS}}{4+(2\pi f  \tau_{RTS})^2},"/></p>
<p>where <img class="math" src="_images/math/4c303cf30d7280f9752bb69a274e3fdd39cdd1dc.png" alt="\tau_{RTS}"/> is the RTS characteristic time constant [sec] and <img class="math" src="_images/math/a4fc23a872f791c8ef45674204aea6493a87e447.png" alt="\Delta I"/> is the source follower current modulation induced by RTS [A].</p>
<p>The source follower noise can be approximated as:</p>
<p><img class="math" src="_images/math/98db428fc9e677f4ab0db901daccef1b6edf9eba.png" alt="\sigma_{SF} = \frac{\sqrt{\int\limits_{0}^{\infty} S_{SF}(f) H_{CDS}(f) df }}{A_{SN}A_{SF}(1-\exp^{-t_s/\tau_D})}"/></p>
<p>where:
-  <img class="math" src="_images/math/7d2e40e7496e1419fc5b0643d6149444b21919bf.png" alt="\sigma_{SF}"/> is the source follower noise [e- rms]
-  <img class="math" src="_images/math/875eb40014526135383caa89fd500ae40a835f56.png" alt="f"/> is the electrical frequency [Hz]
-  <img class="math" src="_images/math/2f8665a2cb06d035e069b6472a88989d912e41da.png" alt="t_s"/> is the CDS sample-to-sampling time [sec]
-  <img class="math" src="_images/math/597340f7dd7877b99e0dc6b4a5b5786bb1f60b60.png" alt="\tau_D"/> is the CDS dominant time constant (see Janesick&#8217;s Scientific CCDs book) usually set as <img class="math" src="_images/math/9b0de76552959837a064f84ee9f1db5e2ec144c2.png" alt="\tau_D = 0.5t_s"/> [sec].</p>
<p>The <img class="math" src="_images/math/ff5039d62fe9b90fb82e5ada7283d780992cc333.png" alt="H_{CDS}(f)"/> function is the CDS transfer function is (see Janesick&#8217;s book):</p>
<p><img class="math" src="_images/math/f87defe61dff327382e4d46d87f2be3c0f9d445c.png" alt="H_{CDS}(f) = \frac{1}{1+(2\pi f \tau_D)^2} \cdot [2-2\cos(2\pi f t_s)]"/></p>
<p>First term sets the CDS bandwidth for the white noise rejection before sampling takes place 
through <img class="math" src="_images/math/e92110d31106f82a060b21c5154f1e74fe057997.png" alt="B = 1/(4\tau_D)"/>, where <img class="math" src="_images/math/9805f44feec6f81d376d09e88b8236635edbb3c8.png" alt="B"/> is defined as the noise equivalent bandwidth [Hz].</p>
<p>Note: In CCD photosensors, source follower noise is typically limited by the flicker noise.</p>
<p>Note: In CMOS photosensors, source follower noise is typically limited by the RTS noise.
As a side note, such subtle kind of noises is visible only on high-end ADC like 16 bit and more.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><div class="first last line-block">
<div class="line">strh5 (hdf5 file): hdf5 file that defines all simulation parameters</div>
</div>
</dd>
<dt>Returns:</dt>
<dd><div class="first last line-block">
<div class="line">in strh5: (hdf5 file) updated data fields</div>
</div>
</dd>
<dt>Raises:</dt>
<dd><div class="first last line-block">
<div class="line">No exception is raised.</div>
</div>
</dd>
</dl>
<p>Author: Mikhail V. Konnik, revised/ported by CJ Willers</p>
<p>Original source: <a class="reference external" href="http://arxiv.org/pdf/1412.4031.pdf">http://arxiv.org/pdf/1412.4031.pdf</a></p>
</dd></dl>

<dl class="function">
<dt id="pyradi.rystare.multiply_detector_area">
<code class="descclassname">pyradi.rystare.</code><code class="descname">multiply_detector_area</code><span class="sig-paren">(</span><em>strh5</em><span class="sig-paren">)</span><a class="headerlink" href="#pyradi.rystare.multiply_detector_area" title="Permalink to this definition">¶</a></dt>
<dd><p>This routine multiplies  detector area</p>
<p>The input to the model of the photosensor is assumed to be a matrix <img class="math" src="_images/math/ab89d1660ed731d08f015401b5dd198140831e59.png" alt="E_{q}\in R^{N\times M}"/> 
that has been converted to electronrate irradiance, corresponding to electron rate  [e/(m2.s)].  
The electron rate irriance is converted to electron rate into the pixel by accounting for 
detector area:</p>
<p><img class="math" src="_images/math/5d1f1fe7c283e087bd9b8230fad834135f0fa776.png" alt="\Phi_{q}  =  \textrm{round} \left(  E_{q} \cdot P_A    \right),"/></p>
<p>where <img class="math" src="_images/math/eca870c3beafdfcea0fd7a8ad7e1de3cbde49640.png" alt="P_A"/> is the area of a pixel [m2].</p>
<blockquote>
<div><dl class="docutils">
<dt>Args:</dt>
<dd><div class="first last line-block">
<div class="line">strh5 (hdf5 file): hdf5 file that defines all simulation parameters</div>
</div>
</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd><div class="first last line-block">
<div class="line">in strh5: (hdf5 file) updated data fields</div>
</div>
</dd>
<dt>Raises:</dt>
<dd><div class="first last line-block">
<div class="line">No exception is raised.</div>
</div>
</dd>
</dl>
<p>Author: Mikhail V. Konnik, revised/ported by CJ Willers</p>
<p>Original source: <a class="reference external" href="http://arxiv.org/pdf/1412.4031.pdf">http://arxiv.org/pdf/1412.4031.pdf</a></p>
</dd></dl>

<dl class="function">
<dt id="pyradi.rystare.multiply_integration_time">
<code class="descclassname">pyradi.rystare.</code><code class="descname">multiply_integration_time</code><span class="sig-paren">(</span><em>strh5</em><span class="sig-paren">)</span><a class="headerlink" href="#pyradi.rystare.multiply_integration_time" title="Permalink to this definition">¶</a></dt>
<dd><p>This routine multiplies with integration time</p>
<p>The input to the model of the photosensor is assumed to be a matrix <img class="math" src="_images/math/ab89d1660ed731d08f015401b5dd198140831e59.png" alt="E_{q}\in R^{N\times M}"/> 
that has been converted to electrons, corresponding to electron rate  [e/s].  
The electron rate is converted to electron count into the pixel by accounting for 
detector integration time:</p>
<p><img class="math" src="_images/math/86d52f73945c6051206fe4db74111ab2f7dc97e1.png" alt="\Phi_{q}  =  \textrm{round} \left(  E_{q} \cdot t_I  \right),"/></p>
<p>where <img class="math" src="_images/math/58b34888c11dd8a5f22a7e9c5fe72a9a63782b24.png" alt="t_{I}"/> is integration     (exposure) time.</p>
<blockquote>
<div><dl class="docutils">
<dt>Args:</dt>
<dd><div class="first last line-block">
<div class="line">strh5 (hdf5 file): hdf5 file that defines all simulation parameters</div>
</div>
</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd><div class="first last line-block">
<div class="line">in strh5: (hdf5 file) updated data fields</div>
</div>
</dd>
<dt>Raises:</dt>
<dd><div class="first last line-block">
<div class="line">No exception is raised.</div>
</div>
</dd>
</dl>
<p>Author: Mikhail V. Konnik, revised/ported by CJ Willers</p>
<p>Original source: <a class="reference external" href="http://arxiv.org/pdf/1412.4031.pdf">http://arxiv.org/pdf/1412.4031.pdf</a></p>
</dd></dl>

<dl class="function">
<dt id="pyradi.rystare.convert_to_electrons">
<code class="descclassname">pyradi.rystare.</code><code class="descname">convert_to_electrons</code><span class="sig-paren">(</span><em>strh5</em><span class="sig-paren">)</span><a class="headerlink" href="#pyradi.rystare.convert_to_electrons" title="Permalink to this definition">¶</a></dt>
<dd><p>This routine converts photon rate irradiance to electron rate irradiance</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><div class="first last line-block">
<div class="line">strh5 (hdf5 file): hdf5 file that defines all simulation parameters</div>
</div>
</dd>
<dt>Returns:</dt>
<dd><div class="first last line-block">
<div class="line">in strh5: (hdf5 file) updated data fields</div>
</div>
</dd>
<dt>Raises:</dt>
<dd><div class="first last line-block">
<div class="line">No exception is raised.</div>
</div>
</dd>
</dl>
<p>Author: Mikhail V. Konnik, revised/ported by CJ Willers</p>
<p>Original source: <a class="reference external" href="http://arxiv.org/pdf/1412.4031.pdf">http://arxiv.org/pdf/1412.4031.pdf</a></p>
</dd></dl>

<dl class="function">
<dt id="pyradi.rystare.shotnoise">
<code class="descclassname">pyradi.rystare.</code><code class="descname">shotnoise</code><span class="sig-paren">(</span><em>sensor_signal_in</em><span class="sig-paren">)</span><a class="headerlink" href="#pyradi.rystare.shotnoise" title="Permalink to this definition">¶</a></dt>
<dd><p>This routine adds photon shot noise to the signal of the photosensor that is in photons.</p>
<p>The photon shot noise is due to the random arrival of photons and can be
described by a Poisson process. Therefore, for each <img class="math" src="_images/math/c07d7ddf20cb31710d4f0e8022b1822fc60ae9bc.png" alt="(i,j)"/>-th element of
the matrix <img class="math" src="_images/math/c2c143e4c64c599fa6ca5c27239a653d6067316d.png" alt="\Phi_{q}"/> that contains the number of collected photons, a photon
shot noise  is simulated as a Poisson process <img class="math" src="_images/math/44ad79f4db8277d12b1a6f5def2d30122c89b9b0.png" alt="\mathcal{P}"/> with mean
<img class="math" src="_images/math/5b99ed91598429157b547a2c3700a6b25c52824a.png" alt="\Lambda"/>:</p>
<p><img class="math" src="_images/math/449dc50fc12eae44e510011394ae10c7ad9f587d.png" alt="\Phi_{ph.shot}=\mathcal{P}(\Lambda), \,\,\,\,\mbox{ where   } \Lambda = \Phi_{q}."/></p>
<p>We use the <cite>ryutils.poissonarray</cite> function that generates Poisson random numbers
with mean <img class="math" src="_images/math/5b99ed91598429157b547a2c3700a6b25c52824a.png" alt="\Lambda"/>.  That is, the number of collected photons in 
<img class="math" src="_images/math/c07d7ddf20cb31710d4f0e8022b1822fc60ae9bc.png" alt="(i,j)"/>-th pixel of the simulated photosensor in the matrix <img class="math" src="_images/math/c2c143e4c64c599fa6ca5c27239a653d6067316d.png" alt="\Phi_{q}"/> is
used as the mean <img class="math" src="_images/math/5b99ed91598429157b547a2c3700a6b25c52824a.png" alt="\Lambda"/> for the generation of Poisson random numbers to
simulate the photon shot noise. The input of the <cite>ryutils.poissonarray</cite> function will
be the matrix <img class="math" src="_images/math/c2c143e4c64c599fa6ca5c27239a653d6067316d.png" alt="\Phi_{q}"/> that contains the number of collected photons. The
output will be the matrix <img class="math" src="_images/math/c55c7e271052eb0c99296f28ec674128294ff76d.png" alt="\Phi_{ph.shot} \rightarrow \Phi_{q}"/>, i.e., the signal
with added photon shot noise.  The matrix <img class="math" src="_images/math/3cac280bafca34bca5b959ace3d59837475e7c97.png" alt="\Phi_{ph.shot}"/> is recalculated
each time the simulations are started, which corresponds to the temporal nature
of the photon shot noise.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><div class="first last line-block">
<div class="line">sensor_signal_in (np.array[N,M]): photon irradiance in, in photons</div>
</div>
</dd>
<dt>Returns:</dt>
<dd><div class="first last line-block">
<div class="line">sensor_signal_out (np.array[N,M]): photon signal out, in photons</div>
</div>
</dd>
<dt>Raises:</dt>
<dd><div class="first last line-block">
<div class="line">No exception is raised.</div>
</div>
</dd>
</dl>
<p>Author: Mikhail V. Konnik, revised/ported by CJ Willers</p>
<p>Original source: <a class="reference external" href="http://arxiv.org/pdf/1412.4031.pdf">http://arxiv.org/pdf/1412.4031.pdf</a></p>
</dd></dl>

<dl class="function">
<dt id="pyradi.rystare.responsivity_FPN_light">
<code class="descclassname">pyradi.rystare.</code><code class="descname">responsivity_FPN_light</code><span class="sig-paren">(</span><em>strh5</em><span class="sig-paren">)</span><a class="headerlink" href="#pyradi.rystare.responsivity_FPN_light" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiploying the photon signal with the PRNU.</p>
<p>The Photo Response Non-Uniformity (PRNU) is the spatial variation in pixel
conversion gain (from photons to electrons). When viewing a uniform scene the pixel signals will 
differ because of the PRNU,  mainly due to variations in the individual pixel&#8217;s characteristics
such as detector area and spectral response. These variations occur during the manufacture 
of the substrate and the detector device.</p>
<p>The PRNU is signal-dependent (proportional to the input signal) and is
fixed-pattern (time-invariant). For visual (silicon) sensors the PRNU factor is typically
<img class="math" src="_images/math/96beab21ce29be4c5784110b2911b2165888cfee.png" alt="0.01\dots 0.05"/>, but for HgCdTe sensors it can be as large as  <img class="math" src="_images/math/648bd40ba6db8ad23afd607696a1eccecb648a22.png" alt="0.02\dots 0.25"/>.
It varies from sensor to sensor, even within the same manufacturing batch.</p>
<p>The photo response non-uniformity (PRNU) is considered as a temporally-fixed light 
signal non-uniformity. The PRNU is modelled using a Gaussian distribution for each
<img class="math" src="_images/math/c07d7ddf20cb31710d4f0e8022b1822fc60ae9bc.png" alt="(i,j)"/>-th pixel of the matrix <img class="math" src="_images/math/ee054c45800635ba4edb92074145abef758a4721.png" alt="I_{e^-}"/>, 
as <img class="math" src="_images/math/61acdd67bf1091d6b13c0cd4a4426ff9e980b3e1.png" alt="I_{PRNU.e^-}=I_{e^-}(1+\mathcal{N}(0,\sigma_{PRNU}^2))"/>
where <img class="math" src="_images/math/0e7abb4a681b7caadafa914d2d67886be09f4d15.png" alt="\sigma_{PRNU}"/> is the PRNU factor value.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><div class="first last line-block">
<div class="line">strh5 (hdf5 file): hdf5 file that defines all simulation parameters</div>
</div>
</dd>
<dt>Returns:</dt>
<dd><div class="first last line-block">
<div class="line">in strh5: (hdf5 file) updated data fields</div>
</div>
</dd>
<dt>Raises:</dt>
<dd><div class="first last line-block">
<div class="line">No exception is raised.</div>
</div>
</dd>
</dl>
<p>Author: Mikhail V. Konnik, revised/ported by CJ Willers</p>
<p>Original source: <a class="reference external" href="http://arxiv.org/pdf/1412.4031.pdf">http://arxiv.org/pdf/1412.4031.pdf</a></p>
</dd></dl>

<dl class="function">
<dt id="pyradi.rystare.responsivity_FPN_dark">
<code class="descclassname">pyradi.rystare.</code><code class="descname">responsivity_FPN_dark</code><span class="sig-paren">(</span><em>strh5</em><span class="sig-paren">)</span><a class="headerlink" href="#pyradi.rystare.responsivity_FPN_dark" title="Permalink to this definition">¶</a></dt>
<dd><p>Add dark current noises that consist of Dark FPN and Dark shot noise.</p>
<p>Pixels in a hardware photosensor cannot be manufactured exactly the same from
perfectly pure materials. There will always be variations in the photo detector
area that are spatially uncorrelated, surface defects at
the <img class="math" src="_images/math/b457dff47eae7ceef13ec8d82d496917a34f3f36.png" alt="SiO_2/Si"/> interface (see Sakaguchi paper on dark current reduction), 
and discrete     randomly-distributed charge generation centres. These
defects provide a mechanism for thermally-excited carriers to move between the
valence and   conduction bands. Consequently, the average dark   signal is not
uniform but has a spatially-random and fixed-pattern noise (FPN) structure.  The
dark current FPN can be expressed as follows:</p>
<p><img class="math" src="_images/math/3edb9f3fece82a79e7332c58678ebbbea1c0ea92.png" alt="\sigma_{d.FPN} = t_I D_R \cdot D_N,"/></p>
<p>where <img class="math" src="_images/math/1a74b4a95f80b2d8f79f2a667b160ecb2afa5ccc.png" alt="t_I"/> is the integration time, <img class="math" src="_images/math/d4eee146f2ea75afc1a838391089e437ad6d5466.png" alt="D_R"/> is the  average dark current,
and <img class="math" src="_images/math/8c64c1c881c13c8ed4054536bea1625a44fa42f0.png" alt="D_N"/> is the dark current FPN factor that is typically <img class="math" src="_images/math/1a48ea45d7339b6a5b0ecc243f460540501cf3f2.png" alt="0.1\dots 0.4"/> for CCD and CMOS sensors.</p>
<p>There are also so called &#8216;outliers&#8217; or &#8216;dark spikes&#8217;; that is, some pixels generate a dark
signal values much higher than the mean value of the dark signal. The mechanism
of such &#8216;dark spikes&#8217; or &#8216;outliers&#8217; can be described by the Poole-Frenkel
effect (increase in emission rate from a defect in the presence of an electric field).</p>
<p><em>Simulation of dark current fixed pattern noise</em></p>
<p>The dark current Fixed
Pattern Noise (FPN) is simulated using non-symmetric distributions to account
for the &#8216;outliers&#8217; or &#8216;hot pixels&#8217;. It is usually assumed that the dark
current FPN can be described by Gaussian distribution. However, such an
assumption provides a poor approximation of a complicated noise picture.</p>
<p>Studies show that a
more adequate model of dark current FPN is to use non-symmetric probability
distributions. The concept is to use two distributions to describe very
&#8216;leaky&#8217; pixels that exhibit higher noise level than others. The first
distribution is used for the main body of the dark current FPN, with a uniform
distribution  superimposed to model &#8216;leaky&#8217; pixels. For  simulations at
room-temperature (<img class="math" src="_images/math/977b8777e9caf4fae1079ed27c087c75f5956129.png" alt="25^\circ"/> C) authors use a
logistic distribution, where a higher proportion of the population is
distributed in the tails. For higher
temperatures, inverse Gaussian and
Log-Normal distributions have been proposed. The Log-Normal distribution works well for
conventional 3T APS CMOS sensors with comparatively high dark current.</p>
<p>In our simulations we use the Log-Normal distribution for the simulation of dark
current FPN in the case of short integration times, and superimposing other
distributions for long integration times. The actual simulation code implements
various models, including Log-Normal, Gaussian, and Wald distribution to emulate
the dark current FPN noise for short- and long-term integration times.</p>
<p>The dark current FPN for each pixel of the matrix <img class="math" src="_images/math/7f45d9dd5e78b8e641dd04a59090e34a42a69f4a.png" alt="I_{dc.shot.e^-}"/> is computed as:</p>
<p><img class="math" src="_images/math/71a36f014abb29ca24842fdf227885265a56db09.png" alt="I_{dc.FPN.e^-}  = I_{dc.shot.e^-}  + I_{dc.shot.e^-} \cdot ln\mathcal{N}(0,\sigma_{dc.FPN.e^-}^2)"/></p>
<p>where <img class="math" src="_images/math/880b9a3aedd4d8f5c76b4b3d6151e62dd5b7b6a3.png" alt="\sigma_{dc.FPN.e^-} = t_I D_R  D_N"/>, <img class="math" src="_images/math/d4eee146f2ea75afc1a838391089e437ad6d5466.png" alt="D_R"/> is the average dark current, 
and <img class="math" src="_images/math/8c64c1c881c13c8ed4054536bea1625a44fa42f0.png" alt="D_N"/> is the dark current FPN factor.
Since the dark current FPN does not change from one frame to the next,  the
matrix <img class="math" src="_images/math/a02a9220e2f9e7df0ed34af506162e7bd2439204.png" alt="ln \mathcal{N}"/> is calculated once and then can be re-used similar to
the PRNU simulations.</p>
<p>The experimental results confirm
that non-symmetric models, and in particular the Log-Normal distribution, 
adequately  describe the dark current FPN in CMOS sensors, especially in the
case of a long integration time (longer than 30-60 seconds).  For long-exposure case, one
needs to superimpose two (or more, depending on the sensor) probability
distributions.</p>
<blockquote>
<div><dl class="docutils">
<dt>Args:</dt>
<dd><div class="first last line-block">
<div class="line">strh5 (hdf5 file): hdf5 file that defines all simulation parameters</div>
</div>
</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd><div class="first last line-block">
<div class="line">in strh5: (hdf5 file) updated data fields</div>
</div>
</dd>
<dt>Raises:</dt>
<dd><div class="first last line-block">
<div class="line">No exception is raised.</div>
</div>
</dd>
</dl>
<p>Author: Mikhail V. Konnik, revised/ported by CJ Willers</p>
<p>Original source: <a class="reference external" href="http://arxiv.org/pdf/1412.4031.pdf">http://arxiv.org/pdf/1412.4031.pdf</a></p>
</dd></dl>

<dl class="function">
<dt id="pyradi.rystare.FPN_models">
<code class="descclassname">pyradi.rystare.</code><code class="descname">FPN_models</code><span class="sig-paren">(</span><em>sensor_signal_rows</em>, <em>sensor_signal_columns</em>, <em>noisetype</em>, <em>noisedistribution</em>, <em>spread</em>, <em>filter_params=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyradi.rystare.FPN_models" title="Permalink to this definition">¶</a></dt>
<dd><p>The routine contains various models on simulation of Fixed Pattern Noise.</p>
<p>There are many models for simulation of the FPN: some of the models are suitable
for short-exposure time modelling (Gaussian), while other models are more suitable 
for log-exposure modelling of dark current FPN.</p>
<p><em>Gaussian model (Janesick-Gaussian)</em></p>
<p>Fixed-pattern noise (FPN) arises from changes in dark currents due to variations
in pixel geometry during fabrication of the sensor. FPN increases exponentially
with temperature and can be measured in dark conditions. 
Column FPN is caused by offset in the integrating amplifier,
size variations in the integrating capacitor CF, channel charge injection from
reset circuit. FPN components that are reduced by CDS.
Dark current FPN can be expressed as:</p>
<p><img class="math" src="_images/math/b3c73c31bbba15078b68100ae56eded354dc04d9.png" alt="\sigma_{D_{FPN}} = D\cdot D_N,"/></p>
<p>where <img class="math" src="_images/math/8c64c1c881c13c8ed4054536bea1625a44fa42f0.png" alt="D_N"/> is the dark current FPN quality, which is typically between 10%
and 40% for CCD and CMOS sensors (see Janesick&#8217;s book), and  <img class="math" src="_images/math/212ac4325233a26edde535f5701af4b35e590ac6.png" alt="D = t_I D_R"/>. 
There are other models of dark FPN, for instance as a autoregressive process.</p>
<p><em>El Gamal model of FPN with Autoregressive process</em></p>
<p>To capture the structure of FPN in a CMOS sensor we express <img class="math" src="_images/math/03908510450a7d7fe2655a516913c4ade2ac6795.png" alt="F_{i,j}"/> as the
sum of a column FPN component <img class="math" src="_images/math/00cfd79cecfc9c96b8774e95ed19be3737a57485.png" alt="Y_j"/> and a pixel FPN component <img class="math" src="_images/math/d907cfb01886c1578f22b66ee9dbd190ad70e2a1.png" alt="X_{i,j}"/>.
Thus, <img class="math" src="_images/math/c5c573b40e4d560f2b66c0a235fafcfcb58cb6b0.png" alt="F_{i,j} = Y_j + X_{i,j},"/> where the <img class="math" src="_images/math/00cfd79cecfc9c96b8774e95ed19be3737a57485.png" alt="Y_j"/>&#8216;s and the
<img class="math" src="_images/math/d907cfb01886c1578f22b66ee9dbd190ad70e2a1.png" alt="X_{i,j}"/>&#8216;s are zero mean random variables.</p>
<p>The first assumption is that the random processes
<img class="math" src="_images/math/43766e73cfa6746686610177cb76b61228ae1f88.png" alt="Y_{j}"/> and <img class="math" src="_images/math/d907cfb01886c1578f22b66ee9dbd190ad70e2a1.png" alt="X_{i,j}"/> are uncorrelated. This assumption is reasonable
since the column and pixel FPN are caused by different device parameter
variations. We further assume that the column (and pixel) FPN processes are
isotropic.</p>
<p>The idea to use autoregressive processes to model FPN was proposed because their
parameters can be easily and efficiently estimated from data.
The simplest model, namely first order isotropic
autoregressive processes is considered.  This model can be extended to higher order
models, however, the results suggest that additional model complexity may not be
warranted.</p>
<p>The model assumes that the column FPN process <img class="math" src="_images/math/43766e73cfa6746686610177cb76b61228ae1f88.png" alt="Y_{j}"/> is a first order
isotropic autoregressive process of the form:</p>
<p><img class="math" src="_images/math/4179577da6267e97623b3a11065a15905173acb8.png" alt="Y_j = a(Y_{j-1}+Y_{j+1}) + U_j"/></p>
<p>where the <img class="math" src="_images/math/b6370e9b1d0b4027349011036660d2272cdf6e4f.png" alt="U_j"/> s are zero mean, uncorrelated random variables with the same
variance <img class="math" src="_images/math/6ecaaa07b3b433584a92c14752863a41cef45773.png" alt="\sigma_U"/> , and <img class="math" src="_images/math/ecb0f7b14dac6005e4481aa577dcf4939e592c62.png" alt="0 \leq a \leq 1"/> is a parameter that
characterises the dependency of <img class="math" src="_images/math/43766e73cfa6746686610177cb76b61228ae1f88.png" alt="Y_{j}"/> on its two neighbours.</p>
<p>The model assumes that the pixel FPN process <img class="math" src="_images/math/d907cfb01886c1578f22b66ee9dbd190ad70e2a1.png" alt="X_{i,j}"/> is a two dimensional
first order isotropic autoregressive process of the form:</p>
<p><img class="math" src="_images/math/748716ad60fb3609e995f2152419305447bf22a8.png" alt="X_{i,j} = b(X_{i-1,j} + X_{i+1,j} +  X_{i,j-1} + X_{i,j+1} ) + V_{i,j}"/></p>
<p>where the <img class="math" src="_images/math/b0bbd51f6518babf9df97d1a18ea98eec5eae012.png" alt="V_{i,j}"/> s are zero mean uncorrelated random variables with the
same variance <img class="math" src="_images/math/d3bdbfc6e39401be3fda51df1e6564721a13e6f0.png" alt="\sigma_V"/> , and  <img class="math" src="_images/math/d5b17aecd7ad051b7015406c03a0d0b9fa0975f5.png" alt="0 \leq b \leq 1"/> is a parameter that
characterises the dependency of <img class="math" src="_images/math/d907cfb01886c1578f22b66ee9dbd190ad70e2a1.png" alt="X_{i,j}"/> on its four neighbours.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><div class="first last line-block">
<div class="line">sensor_signal_rows(int): number of rows in the signal matrix</div>
<div class="line">sensor_signal_columns(int): number of columns in the signal matrix</div>
<div class="line">noisetype(string): type of noise to generate: [&#8216;pixel&#8217; or &#8216;column&#8217;]</div>
<div class="line">noisedistribution(string): the probability distribution name [&#8216;AR-ElGamal&#8217;, &#8216;Janesick-Gaussian&#8217;, &#8216;Wald&#8217;, &#8216;LogNormal&#8217;]</div>
<div class="line">spread(float): spread around mean value (sigma/chi/lambda) for the probability distribution</div>
<div class="line">filter_params([nd.array]): a vector of parameters for the probability filter</div>
</div>
</dd>
<dt>Returns:</dt>
<dd><div class="first last line-block">
<div class="line">noiseout (np.array[N,M]): generated noise of FPN.</div>
</div>
</dd>
<dt>Raises:</dt>
<dd><div class="first last line-block">
<div class="line">No exception is raised.</div>
</div>
</dd>
</dl>
<p>Author: Mikhail V. Konnik, revised/ported by CJ Willers</p>
<p>Original source: <a class="reference external" href="http://arxiv.org/pdf/1412.4031.pdf">http://arxiv.org/pdf/1412.4031.pdf</a></p>
</dd></dl>

<dl class="function">
<dt id="pyradi.rystare.nEcntLLightDF">
<code class="descclassname">pyradi.rystare.</code><code class="descname">nEcntLLightDF</code><span class="sig-paren">(</span><em>tauAtmo</em>, <em>tauFilt</em>, <em>tauOpt</em>, <em>quantEff</em>, <em>rhoTarg</em>, <em>cosTarg</em>, <em>inttime</em>, <em>pfrac</em>, <em>detarea</em>, <em>fno</em>, <em>scenario</em>, <em>specBand</em>, <em>dfPhotRates</em><span class="sig-paren">)</span><a class="headerlink" href="#pyradi.rystare.nEcntLLightDF" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the number of electrons in a detector given sensor parameters
and photon radiance dataframe</p>
<p>All values in base SI units</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><div class="first last line-block">
<div class="line">tauAtmo (scalar or nd.array): atmosphere transmittance</div>
<div class="line">tauFilt (scalar or nd.array):  sensor filter transmittance</div>
<div class="line">tauOpt (scalar or nd.array):   sensor optics transmittance</div>
<div class="line">quantEff (scalar or nd.array): sensor detector quantum efficiency</div>
<div class="line">rhoTarg (scalar or nd.array):  target diffuse reflectance </div>
<div class="line">cosTarg (scalar):  cos of illuminator angle wrt normal vector </div>
<div class="line">inttime (scalar): integration time s </div>
<div class="line">pfrac (scalar): fraction of clear optics </div>
<div class="line">detarea (scalar): detector area m2</div>
<div class="line">fno (scalar): f number </div>
<div class="line">scenario (str): Scenario as key to rypflux.py dataframe</div>
<div class="line">specBand (str): Spectral band as key to rypflux.py dataframe</div>
<div class="line">dfPhotRadiance (pd.DataFrame): rypflux.py dataframe radiance in q/(s.m2.sr) </div>
</div>
</dd>
<dt>Returns:</dt>
<dd><div class="first last line-block">
<div class="line">n (float): number of electrons in charge well</div>
</div>
</dd>
<dt>Raises:</dt>
<dd><div class="first last line-block">
<div class="line">No exception is raised.</div>
</div>
</dd>
</dl>
<p>Author: CJ Willers</p>
</dd></dl>

<dl class="function">
<dt id="pyradi.rystare.nEcntLLightPhotL">
<code class="descclassname">pyradi.rystare.</code><code class="descname">nEcntLLightPhotL</code><span class="sig-paren">(</span><em>tauAtmo</em>, <em>tauFilt</em>, <em>tauOpt</em>, <em>quantEff</em>, <em>rhoTarg</em>, <em>cosTarg</em>, <em>inttime</em>, <em>pfrac</em>, <em>detarea</em>, <em>fno</em>, <em>photRadiance</em><span class="sig-paren">)</span><a class="headerlink" href="#pyradi.rystare.nEcntLLightPhotL" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the number of electrons in a detector given sensor parameters
and photon radiance</p>
<p>All values in base SI units</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><div class="first last line-block">
<div class="line">tauAtmo (scalar or nd.array): atmosphere transmittance</div>
<div class="line">tauFilt (scalar or nd.array):  sensor filter transmittance</div>
<div class="line">tauOpt (scalar or nd.array):   sensor optics transmittance</div>
<div class="line">quantEff (scalar or nd.array): sensor detector quantum efficiency</div>
<div class="line">rhoTarg (scalar or nd.array):  target diffuse reflectance </div>
<div class="line">cosTarg (scalar):  cos of illuminator angle wrt normal vector </div>
<div class="line">inttime (scalar): integration time s </div>
<div class="line">pfrac (scalar): fraction of clear optics </div>
<div class="line">detarea (scalar): detector area m2</div>
<div class="line">fno (scalar): f number </div>
<div class="line">photRadiance (scalar): in-band photon radiance q/(s.m2.sr)</div>
</div>
</dd>
<dt>Returns:</dt>
<dd><div class="first last line-block">
<div class="line">n (float): number of electrons in charge well</div>
</div>
</dd>
<dt>Raises:</dt>
<dd><div class="first last line-block">
<div class="line">No exception is raised.</div>
</div>
</dd>
</dl>
<p>Author: CJ Willers</p>
</dd></dl>

<dl class="function">
<dt id="pyradi.rystare.nElecCntThermalScene">
<code class="descclassname">pyradi.rystare.</code><code class="descname">nElecCntThermalScene</code><span class="sig-paren">(</span><em>wl</em>, <em>tmptr</em>, <em>emis</em>, <em>tauAtmo</em>, <em>tauFilt</em>, <em>tauOpt</em>, <em>quantEff</em>, <em>inttime</em>, <em>pfrac</em>, <em>detarea</em>, <em>fno</em><span class="sig-paren">)</span><a class="headerlink" href="#pyradi.rystare.nElecCntThermalScene" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the number of electrons in a detector from a thermal source</p>
<p>All values in base SI units</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><div class="first last line-block">
<div class="line">wl (np.array): wavelength vector </div>
<div class="line">tmptr (scalar): source temperature</div>
<div class="line">emis (np.array of scalar): source emissivity</div>
<div class="line">tauAtmo (scalar or nd.array): atmosphere transmittance</div>
<div class="line">tauFilt (scalar or nd.array):  sensor filter transmittance</div>
<div class="line">tauOpt (scalar or nd.array):   sensor optics transmittance</div>
<div class="line">quantEff (scalar or nd.array): sensor detector quantum efficiency</div>
<div class="line">inttime (scalar): integration time s </div>
<div class="line">pfrac (scalar): fraction of clear optics </div>
<div class="line">detarea (scalar): detector area m2</div>
<div class="line">fno (scalar): f number </div>
</div>
</dd>
<dt>Returns:</dt>
<dd><div class="first last line-block">
<div class="line">n (float): number of electrons in charge well</div>
</div>
</dd>
<dt>Raises:</dt>
<dd><div class="first last line-block">
<div class="line">No exception is raised.</div>
</div>
</dd>
</dl>
<p>Author: CJ Willers</p>
</dd></dl>

<dl class="function">
<dt id="pyradi.rystare.nEcntThermalOptics">
<code class="descclassname">pyradi.rystare.</code><code class="descname">nEcntThermalOptics</code><span class="sig-paren">(</span><em>wl</em>, <em>tmptrOpt</em>, <em>tauFilt</em>, <em>tauOpt</em>, <em>quantEff</em>, <em>inttime</em>, <em>pfrac</em>, <em>detarea</em>, <em>fno</em><span class="sig-paren">)</span><a class="headerlink" href="#pyradi.rystare.nEcntThermalOptics" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the number of electrons in a detector from hot optics</p>
<p>All values in base SI units</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><div class="first last line-block">
<div class="line">wl (np.array): wavelength vector </div>
<div class="line">tmptrOpt (scalar): optics temperature</div>
<div class="line">tauFilt (scalar or nd.array):  sensor filter transmittance</div>
<div class="line">tauOpt (scalar or nd.array):   sensor optics transmittance</div>
<div class="line">quantEff (scalar or nd.array): sensor detector quantum efficiency</div>
<div class="line">inttime (scalar): integration time s </div>
<div class="line">pfrac (scalar): fraction of clear optics </div>
<div class="line">detarea (scalar): detector area m2</div>
<div class="line">fno (scalar): f number </div>
</div>
</dd>
<dt>Returns:</dt>
<dd><div class="first last line-block">
<div class="line">n (float): number of electrons in charge well</div>
</div>
</dd>
<dt>Raises:</dt>
<dd><div class="first last line-block">
<div class="line">No exception is raised.</div>
</div>
</dd>
</dl>
<p>Author: CJ Willers</p>
</dd></dl>

<dl class="function">
<dt id="pyradi.rystare.nElecCntReflSun">
<code class="descclassname">pyradi.rystare.</code><code class="descname">nElecCntReflSun</code><span class="sig-paren">(</span><em>wl</em>, <em>tauSun</em>, <em>tauAtmo=1</em>, <em>tauFilt=1</em>, <em>tauOpt=1</em>, <em>quantEff=1</em>, <em>rhoTarg=1</em>, <em>cosTarg=1</em>, <em>inttime=1</em>, <em>pfrac=1</em>, <em>detarea=1</em>, <em>fno=0.8862269255</em>, <em>emissun=1.0</em>, <em>tmprt=6000.0</em><span class="sig-paren">)</span><a class="headerlink" href="#pyradi.rystare.nElecCntReflSun" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the number of electrons in a detector or photon radiance for reflected sunlight</p>
<p>All values in base SI units.</p>
<p>By using the default values when calling the function the radiance at the 
source can be calculated.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><div class="first last line-block">
<div class="line">wl (np.array (N,) or (N,1)): wavelength </div>
<div class="line">tauSun (np.array (N,) or (N,1)): transmittance between the scene and sun </div>
<div class="line">tauAtmo (np.array (N,) or (N,1)): transmittance between the scene and sensor </div>
<div class="line">tauFilt (np.array (N,) or (N,1)): sensor filter transmittance </div>
<div class="line">tauOpt (np.array (N,) or (N,1)): sensor optics transmittance </div>
<div class="line">quantEff (np.array (N,) or (N,1)): detector quantum efficiency </div>
<div class="line">rhoTarg (np.array (N,) or (N,1)): target diffuse surface reflectance </div>
<div class="line">cosTarg (scalar): cosine between surface normal and sun/moon direction</div>
<div class="line">inttime (scalar): detector integration time</div>
<div class="line">pfrac (scalar):  fraction of optics clear aperture</div>
<div class="line">detarea (scalar): detector area</div>
<div class="line">fno (scalar): optics fnumber</div>
<div class="line">emissun (scalar): sun surface emissivity</div>
<div class="line">tmprt (scalar): sun surface temperature</div>
</div>
</dd>
<dt>Returns:</dt>
<dd><div class="first last line-block">
<div class="line">n (scalar): number of electrons accumulated during integration time</div>
</div>
</dd>
<dt>Raises:</dt>
<dd><div class="first last line-block">
<div class="line">No exception is raised.</div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyradi.rystare.darkcurrentnoise">
<code class="descclassname">pyradi.rystare.</code><code class="descname">darkcurrentnoise</code><span class="sig-paren">(</span><em>inttime</em>, <em>detarea</em>, <em>temptr</em>, <em>Egap</em>, <em>DFM=5e-06</em><span class="sig-paren">)</span><a class="headerlink" href="#pyradi.rystare.darkcurrentnoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the dark current noise given detector parameters</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><div class="first last line-block">
<div class="line">inttime (scalar): integration time in seconds</div>
<div class="line">detarea (scalar): detector area in m2</div>
<div class="line">temptr (scalar): temperature in K</div>
<div class="line">Egap (scalar):  bandgap in eV</div>
<div class="line">DFM (scalar): in units of nA/m2</div>
</div>
</dd>
<dt>Returns:</dt>
<dd><div class="first last line-block">
<div class="line">n (scalar): dark current noise as number of electrons </div>
</div>
</dd>
<dt>Raises:</dt>
<dd><div class="first last line-block">
<div class="line">No exception is raised.</div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyradi.rystare.kTCnoiseCsn">
<code class="descclassname">pyradi.rystare.</code><code class="descname">kTCnoiseCsn</code><span class="sig-paren">(</span><em>temptr</em>, <em>sensecapacity</em><span class="sig-paren">)</span><a class="headerlink" href="#pyradi.rystare.kTCnoiseCsn" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Args:</dt>
<dd><div class="first last line-block">
<div class="line">temptr (scalar): temperature in K</div>
<div class="line">sensecapacity (): sense node capacitance F</div>
</div>
</dd>
<dt>Returns:</dt>
<dd><div class="first last line-block">
<div class="line">n (scalar): noise as number of electrons </div>
</div>
</dd>
<dt>Raises:</dt>
<dd><div class="first last line-block">
<div class="line">No exception is raised.</div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyradi.rystare.kTCnoiseGv">
<code class="descclassname">pyradi.rystare.</code><code class="descname">kTCnoiseGv</code><span class="sig-paren">(</span><em>temptr</em>, <em>gv</em><span class="sig-paren">)</span><a class="headerlink" href="#pyradi.rystare.kTCnoiseGv" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Args:</dt>
<dd><div class="first last line-block">
<div class="line">temptr (scalar): temperature in K</div>
<div class="line">gv (scalar): sense node gain V/e</div>
</div>
</dd>
<dt>Returns:</dt>
<dd><div class="first last line-block">
<div class="line">n (scalar): noise as number of electrons </div>
</div>
</dd>
<dt>Raises:</dt>
<dd><div class="first last line-block">
<div class="line">No exception is raised.</div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyradi.rystare.create_HDF5_image">
<code class="descclassname">pyradi.rystare.</code><code class="descname">create_HDF5_image</code><span class="sig-paren">(</span><em>imageName</em>, <em>imtype</em>, <em>pixelPitch</em>, <em>numPixels</em>, <em>fracdiameter=0</em>, <em>fracblurr=0</em>, <em>irrad_scale=1</em>, <em>irrad_min=0</em>, <em>wavelength=5.5e-07</em>, <em>steps=10</em><span class="sig-paren">)</span><a class="headerlink" href="#pyradi.rystare.create_HDF5_image" title="Permalink to this definition">¶</a></dt>
<dd><p>This routine performs makes a simple illuminated circle with blurred boundaries.</p>
<p>Then the  sensor&#8217;s radiant irradiance in units [W/m2] are converted to  
photon rate irradiance in units [q/m2.s)] by relating one photon&#8217;s energy
to power at the stated wavelength by <img class="math" src="_images/math/55333d84d73c72222cae47f3d690ad911e6aa110.png" alt="Q_p=\frac{h\cdot c}{\lambda}"/>,
where <img class="math" src="_images/math/76f1d8ace30435987c01a00ca53a71cba1f40e6c.png" alt="\lambda"/> is wavelength, <img class="math" src="_images/math/293fb39e1b93282c804a86186e721b32f829f1b2.png" alt="h"/> is Planck&#8217;s constant and <img class="math" src="_images/math/ae12a24f88803b5895632e4848d87d46483c492c.png" alt="c"/> is
the speed of light.</p>
<p>The image file is in HDF5 format, containing the input parameters to the image creation process.
A few minimum entries are required, but you can add any information youo wish to document the
data.  The following minimum HDF5 entries are required by pyradi.rystare:</p>
<blockquote>
<div><div class="line-block">
<div class="line"><code class="docutils literal"><span class="pre">'image/imageName'</span></code> (string):  the image name  </div>
<div class="line"><code class="docutils literal"><span class="pre">'image/PhotonRateIrradianceNoNoise'</span></code> np.array[M,N]:  a float array with the image pixel values no noise </div>
<div class="line"><code class="docutils literal"><span class="pre">'image/PhotonRateIrradiance'</span></code> np.array[M,N]:  a float array with the image pixel values with noise</div>
<div class="line"><code class="docutils literal"><span class="pre">'image/pixelPitch'</span></code>:  ([float, float]):  detector pitch in m [row,col]  </div>
<div class="line"><code class="docutils literal"><span class="pre">'image/imageSizePixels'</span></code>:  ([int, int]): number of pixels [row,col]  </div>
<div class="line"><code class="docutils literal"><span class="pre">'image/imageFilename'</span></code> (string):  the image file name  </div>
<div class="line"><code class="docutils literal"><span class="pre">'image/wavelength'</span></code> (float):  where photon rate calcs are done  um</div>
<div class="line"><code class="docutils literal"><span class="pre">'image/imageSizeRows'</span></code> (int):  the number of image rows</div>
<div class="line"><code class="docutils literal"><span class="pre">'image/imageSizeCols'</span></code> (int):  the number of image cols</div>
<div class="line"><code class="docutils literal"><span class="pre">'image/imageSizeDiagonal'</span></code> (float):  the FPA diagonal size in mm </div>
<div class="line"><code class="docutils literal"><span class="pre">'image/irradianceLux'</span></code> (float):  the maximum luminous exitance in the image lux (optional)</div>
<div class="line"><code class="docutils literal"><span class="pre">'image/irradianceWatts'</span></code> (float):  the maximum exitance in the image W/m2 (optional)</div>
<div class="line"><code class="docutils literal"><span class="pre">'image/temperature'</span></code> (float):  the maximum target temperature in the image K (optional)</div>
</div>
</div></blockquote>
<dl class="docutils">
<dt>Args:</dt>
<dd><div class="first last line-block">
<div class="line">imageName (string): the image name, used to form the filename</div>
<div class="line">imtype (string): string to define the type if image to be created [&#8216;zeros&#8217;,&#8217;disk&#8217;,&#8217;stairslin&#8217;,&#8217;stairslog&#8217;]</div>
<div class="line">pixelPitch ([float, float]):  detector pitch in m [row,col]</div>
<div class="line">numPixels ([int, int]): number of pixels [row,col]</div>
<div class="line">fracdiameter (float):  diameter of the disk as fraction of minimum image size</div>
<div class="line">fracblurr (float):   blurr of the disk as fraction of minimum image size</div>
<div class="line">irrad_scale (float): multiplicative scale factor (max value)</div>
<div class="line">irrad_min (float): additive minimum value in the image</div>
<div class="line">wavelength (float): wavelength where photon rate calcs are done in [m]</div>
<div class="line">steps (int): number of steps in the stairs image</div>
</div>
</dd>
<dt>Returns:</dt>
<dd><div class="first last line-block">
<div class="line">nothing: as a side effect an image file is written</div>
</div>
</dd>
<dt>Raises:</dt>
<dd><div class="first last line-block">
<div class="line">No exception is raised.</div>
</div>
</dd>
</dl>
<p>Author: CJ Willers</p>
</dd></dl>

<dl class="function">
<dt id="pyradi.rystare.define_metrics">
<code class="descclassname">pyradi.rystare.</code><code class="descname">define_metrics</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyradi.rystare.define_metrics" title="Permalink to this definition">¶</a></dt>
<dd><p>This simple routine defines various handy shorthand for cm and mm in the code.</p>
<p>The code defines a number of scaling factors to convert to metres and radians</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><div class="first last line-block">
<div class="line">None</div>
</div>
</dd>
<dt>Returns:</dt>
<dd><div class="first last line-block">
<div class="line">scaling factors.</div>
</div>
</dd>
<dt>Raises:</dt>
<dd><div class="first last line-block">
<div class="line">No exception is raised.</div>
</div>
</dd>
</dl>
<p>Author: Mikhail V. Konnik, revised/ported by CJ Willers</p>
<p>Original source: <a class="reference external" href="http://arxiv.org/pdf/1412.4031.pdf">http://arxiv.org/pdf/1412.4031.pdf</a></p>
</dd></dl>

<dl class="function">
<dt id="pyradi.rystare.limitzero">
<code class="descclassname">pyradi.rystare.</code><code class="descname">limitzero</code><span class="sig-paren">(</span><em>a</em>, <em>thr=0.6</em><span class="sig-paren">)</span><a class="headerlink" href="#pyradi.rystare.limitzero" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs an asymetric clipping to prevent negative values.
The lower-end values are clumped up towards the lower positive values, while 
upper-end values are not affected.</p>
<p>This function is used to prevent negative random variables for wide sigma and low
mean value, e.g., N(1,.5).  If the random variables are passed through this function
The resulting distribution is not normal any more, and has no known analytical form.</p>
<p>A threshold value of around 0.6 was found to work well for N(1,small) up to N(1,.5).</p>
<p>Before you use this function, first check the results using the code below in the main
body of this file.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><div class="first last line-block">
<div class="line">a (np.array): an array of floats, </div>
</div>
</dd>
<dt>Returns:</dt>
<dd><div class="first last line-block">
<div class="line">scaling factors.</div>
</div>
</dd>
<dt>Raises:</dt>
<dd><div class="first last line-block">
<div class="line">No exception is raised.</div>
</div>
</dd>
</dl>
<p>Author: CJ Willers</p>
</dd></dl>

<dl class="function">
<dt id="pyradi.rystare.run_example">
<code class="descclassname">pyradi.rystare.</code><code class="descname">run_example</code><span class="sig-paren">(</span><em>doTest=u'Advanced'</em>, <em>outfilename=u'Output'</em>, <em>pathtoimage=None</em>, <em>doPlots=False</em>, <em>doHisto=False</em>, <em>doImages=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyradi.rystare.run_example" title="Permalink to this definition">¶</a></dt>
<dd><p>This code provides examples of use of the pyradi.rystare model for 
a CMOS/CCD photosensor.</p>
<p>Two models are provided &#8216;simple&#8217; and &#8216;advanced&#8217;</p>
<p>doTest can be &#8216;Simple&#8217; or &#8216;Advanced&#8217;</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><div class="first last line-block">
<div class="line">doTest (string):  which example to run &#8216;Simple&#8217;, or &#8216;Advanced&#8217;</div>
<div class="line">outfilename (string):  filename for output files</div>
<div class="line">pathtoimage (string):  fully qualified path to where the image is located</div>
<div class="line">doPlots (boolean):  flag to control the creation of false colour image plots with colour bars </div>
<div class="line">doHisto (boolean):  flag to control the creation of image histogram plots</div>
<div class="line">doImages (boolean):  flag to control the creation of monochrome image plots </div>
</div>
</dd>
<dt>Returns:</dt>
<dd><div class="first last line-block">
<div class="line">hdffilename (string): output HDF filename</div>
</div>
</dd>
<dt>Raises:</dt>
<dd><div class="first last line-block">
<div class="line">No exception is raised.</div>
</div>
</dd>
</dl>
<p>Author: Mikhail V. Konnik, revised/ported by CJ Willers</p>
<p>Original source: <a class="reference external" href="http://arxiv.org/pdf/1412.4031.pdf">http://arxiv.org/pdf/1412.4031.pdf</a></p>
</dd></dl>

<dl class="function">
<dt id="pyradi.rystare.get_summary_stats">
<code class="descclassname">pyradi.rystare.</code><code class="descname">get_summary_stats</code><span class="sig-paren">(</span><em>hdffilename</em><span class="sig-paren">)</span><a class="headerlink" href="#pyradi.rystare.get_summary_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string with all the summary input and results data.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><div class="first last line-block">
<div class="line">hdffilename (string):  filename for input HDF file</div>
</div>
</dd>
<dt>Returns:</dt>
<dd><div class="first last line-block">
<div class="line">Returns a string with summmary data.</div>
</div>
</dd>
<dt>Raises:</dt>
<dd><div class="first last line-block">
<div class="line">No exception is raised.</div>
</div>
</dd>
</dl>
<p>Author: CJ Willers</p>
</dd></dl>

<table class="docutils citation" frame="void" id="hdf5asdataformat" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[hdf5asdataformat]</a></td><td><a class="reference external" href="https://github.com/NelisW/pyradi/blob/master/pyradi/hdf5-as-data-format.md">https://github.com/NelisW/pyradi/blob/master/pyradi/hdf5-as-data-format.md</a></td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Staring Array Module (rystare)</a><ul>
<li><a class="reference internal" href="#overview">Overview</a></li>
<li><a class="reference internal" href="#signal-flow">Signal Flow</a></li>
<li><a class="reference internal" href="#changes-to-matlab-code">Changes to Matlab code</a></li>
<li><a class="reference internal" href="#example-code">Example Code</a></li>
<li><a class="reference internal" href="#hdf5-file">HDF5 File</a></li>
<li><a class="reference internal" href="#module-pyradi.rystare">Code Overview</a></li>
<li><a class="reference internal" href="#module-functions">Module functions</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="rydetector.html"
                        title="previous chapter">Bulk detector modelling</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="ryprob.html"
                        title="next chapter">Probability tools (ryprob)</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/rystare.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="ryprob.html" title="Probability tools (ryprob)"
             >next</a> |</li>
        <li class="right" >
          <a href="rydetector.html" title="Bulk detector modelling"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">pyradi  documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2012, CJ Willers.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.1.
    </div>
  </body>
</html>